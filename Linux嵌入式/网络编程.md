## 一.网络基础

> 详见计算机网络

### 1.IP地址

互联网中的主机要与别的机器通信**必须具有一个IP地址**

IP地址为32位(IPv4)或者128位(IPv8)

每个数据包都必须携带目的IP地址或源IP地址,路由器依靠此信息为数据包选择路由

常用点分形式表示:

```
192.168.100.225
```

**IP地址的转换**

将strptr所指的字符串转换成32位的网络字节序二进制值

```c
#include <arpa/inet.h>
//将strptr所指的字符串转换成32位的网络字节序二进制值
int inet_aton(const char *strptr, struct in_addr *addrptr);
//功能同上,之间返回转换的值
int_addr_t inet_addr(const char *strptr);
////将二进制形式的IP地址转换为字符串形式
char *inet_ntoa(stuct in_addr inaddr);
///将IPv4/IPv6地址从文本转换为二进制形式
int inet_pton(int af, const char *src, void *dst);

```



```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    //将字符串形式的IP地址转换为二进制形式
    const char *ip_str = "192.168.30.1";
    struct in_addr ip_addr;
    if (inet_pton(AF_INET, ip_str, &ip_addr) != 1) {
        printf("Invalid IP address format\n");
        return 1;
    }
    printf("The binary representation of %s is: 0x%X\n", ip_str, ntohl(ip_addr.s_addr));
    //将字符串形式的IP地址转换为二进制形式（使用inet_addr）
    in_addr_t addr = inet_addr(ip_str);
    if (addr == INADDR_NONE) {
        printf("Invalid IP address format using inet_addr\n");
        return 1;
    }
    printf("The binary representation using inet_addr is: 0x%X\n", ntohl(addr));
    //将二进制形式的IP地址转换为字符串形式
    const char *ip=inet_ntoa(ip_addr);
    if (ip == NULL) {
        printf("Conversion to string failed\n");
        return 1;
    }
    printf("The string representation is: %s\n", ip);
    //将IPv4/IPv6地址从文本转换为二进制形式
    struct in6_addr ipv6_addr;
    const char *ipv6_str = "2001:0db8:85a3:0000:0000:8a2e:0370:7334";
    if (inet_pton(AF_INET6, ipv6_str, &ipv6_addr) != 1) {
        printf("Invalid IPv6 address format\n");
        return 1;
    }
    printf("The IPv6 address has been converted to binary form successfully.\n");
    return 0;
}
```



### 2.端口

为了区分一台主机接收到的数据包应该交给**哪个进程**来处理,使用**端口号**来区别

TCP端口号和UDP端口号独立

- 1~1023(1~255之间为众所周知端口号,256~1023端口通常有UNIX系统占用)
- 注册端口(1023~49150)
- 动态或私有端口(49151~65535)

### 3.Socket

socket(套接字)是网络编程中的一个抽象概念,它允许程序通过网络进行通信

可以将其看作是不同主机之间通信的端点,它提供了应用程序与网络协议栈之间的编程接口

在互联网上,程序之间通过IP地址和端口号组合成的唯一标识Socket来实现不同程序之间的数据交换

Socket可以分为**流式Socket**和**数据报Socket**:

**流式Socket**(SOCK_STREAM):

- 协议:TCP
- 面向连接,可靠
- 数据无差错,不丢失,不重复
- 按顺序到达
- 字节流传输

**数据包Socket**(SOCK_DGRAM)

- 协议UDP
- 无连接,不可靠
- 可能丢失,重复和乱序
- 有消息边界
- 效率高

也可以自己定义**原始Socket**(SOCK_RAW)

- 可以直接访问底层协议

- 用于自定义协议实现

### 4.字节序

不同类型CPU的主机中,内存存储多字节整数序列有两种方法,成为主机字节序(HBO)"

- 小端序:低序字节存储在低地址,将低字节存储在起始地址,
- 大端序:,高序字节存储在低地址,将高字节存储在起始地址

在网络传输中的数据必须按网络字节序,即大端字节序

**字节序转换**

主机字节序到网络字节序(host-to-net)

```c
u_long htonl (u_long hostlong);
u_short htons (u_short short);
```

网络字节序到主机之间序(net-to-host)

```c
u_long ntohl(u_long hostlong);
u_short ntohs (u_short short);
```

---



  ### 二.TCP编程

TCP编程本质上是:

用C语言与Linux内核的 Socket 网络子系统交互,使两个进程(可以是同一台机器,也可以是不同机器)在可靠的双向字节流上通信

所以TCP很适合作为"可靠管道":

浏览访问网页,远程登录(SSH),MQTT/HTTP等协议

---



#### Linux下TCP编程过程

使用TCP编程时,需要做三件事:

1. **创建一个socket(套接字)**:

   socket是一个**内核对象**,行为类似文件描述符(fd)

   ```c
   int sockfd = socket(AF_INET, SOCK_STREAM, 0);
   ```

   `AF_INET` → IPv4

   `SOCK_STREAM` → TCP
   内核返回一个 fd → 类似文件的编号

2. **系统调用**


   > 通过相关功能函数来制定socket的行为

   **bind()**

   - 把socket挂接到某个IP:端口上,让内核知道要监听哪个端口

   **listen()**

   - 告诉内核维持一个半连接队列(SYN队列)和一个已连接队列(accept队列)
   - listen并不会阻塞,它只是上socket进入监听状态

   **accept()**

   > accpet负责创建真正的""通信管道""

   - 阻塞等待三次握手完成
   - 内核创建一个新的socket(专门用于与客户端通信)
   - 把这个新的socket的fd返回(客户端对应的连接通道)
   - 老socket用来监听
   - 新的socket用来通信
3. **TCP三次握手与socket的关系**
   
   ![image-20251116180412890](../assets/image-20251116180412890.png)
   
   三次握手是内核自动处理的,不需要自己发包
   
   
   
   
   



