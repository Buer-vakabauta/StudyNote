## 一.网络基础

> 相关概念详见计算机网络

### 1.IP地址

互联网中的主机要与别的机器通信**必须具有一个IP地址**

IP地址为32位(IPv4)或者128位(IPv8)

每个数据包都必须携带目的IP地址或源IP地址,路由器依靠此信息为数据包选择路由

常用点分形式表示:

```
192.168.100.225
```

**IP地址的转换**

将strptr所指的字符串转换成32位的网络字节序二进制值

```c
#include <arpa/inet.h>
//将strptr所指的字符串转换成32位的网络字节序二进制值
int inet_aton(const char *strptr, struct in_addr *addrptr);
//功能同上,之间返回转换的值
int_addr_t inet_addr(const char *strptr);
////将二进制形式的IP地址转换为字符串形式
char *inet_ntoa(stuct in_addr inaddr);
///将IPv4/IPv6地址从文本转换为二进制形式
int inet_pton(int af, const char *src, void *dst);

```



```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    //将字符串形式的IP地址转换为二进制形式
    const char *ip_str = "192.168.30.1";
    struct in_addr ip_addr;
    if (inet_pton(AF_INET, ip_str, &ip_addr) != 1) {
        printf("Invalid IP address format\n");
        return 1;
    }
    printf("The binary representation of %s is: 0x%X\n", ip_str, ntohl(ip_addr.s_addr));
    //将字符串形式的IP地址转换为二进制形式（使用inet_addr）
    in_addr_t addr = inet_addr(ip_str);
    if (addr == INADDR_NONE) {
        printf("Invalid IP address format using inet_addr\n");
        return 1;
    }
    printf("The binary representation using inet_addr is: 0x%X\n", ntohl(addr));
    //将二进制形式的IP地址转换为字符串形式
    const char *ip=inet_ntoa(ip_addr);
    if (ip == NULL) {
        printf("Conversion to string failed\n");
        return 1;
    }
    printf("The string representation is: %s\n", ip);
    //将IPv4/IPv6地址从文本转换为二进制形式
    struct in6_addr ipv6_addr;
    const char *ipv6_str = "2001:0db8:85a3:0000:0000:8a2e:0370:7334";
    if (inet_pton(AF_INET6, ipv6_str, &ipv6_addr) != 1) {
        printf("Invalid IPv6 address format\n");
        return 1;
    }
    printf("The IPv6 address has been converted to binary form successfully.\n");
    return 0;
}
```



### 2.端口

为了区分一台主机接收到的数据包应该交给**哪个进程**来处理,使用**端口号**来区别

TCP端口号和UDP端口号独立

- 1~1023(1~255之间为众所周知端口号,256~1023端口通常有UNIX系统占用)
- 注册端口(1023~49150)
- 动态或私有端口(49151~65535)

### 3.Socket

socket(套接字)是网络编程中的一个抽象概念,它允许程序通过网络进行通信

可以将其看作是不同主机之间通信的端点,它提供了应用程序与网络协议栈之间的编程接口

在互联网上,程序之间通过IP地址和端口号组合成的唯一标识Socket来实现不同程序之间的数据交换

Socket可以分为**流式Socket**和**数据报Socket**:

**流式Socket**(SOCK_STREAM):

- 协议:TCP
- 面向连接,可靠
- 数据无差错,不丢失,不重复
- 按顺序到达
- 字节流传输

**数据包Socket**(SOCK_DGRAM)

- 协议UDP
- 无连接,不可靠
- 可能丢失,重复和乱序
- 有消息边界
- 效率高

也可以自己定义**原始Socket**(SOCK_RAW)

- 可以直接访问底层协议

- 用于自定义协议实现

### 4.字节序

不同类型CPU的主机中,内存存储多字节整数序列有两种方法,成为主机字节序(HBO)"

- 小端序:低序字节存储在低地址,将低字节存储在起始地址,
- 大端序:,高序字节存储在低地址,将高字节存储在起始地址

在网络传输中的数据必须按网络字节序,即大端字节序

**字节序转换**

主机字节序到网络字节序(host-to-net)

```c
u_long htonl (u_long hostlong);
u_short htons (u_short short);
```

网络字节序到主机之间序(net-to-host)

```c
u_long ntohl(u_long hostlong);
u_short ntohs (u_short short);
```

---



  ### 二.TCP编程

TCP编程本质上是:

用C语言与Linux内核的 Socket 网络子系统交互,使两个进程(可以是同一台机器,也可以是不同机器)在可靠的双向字节流上通信

所以TCP很适合作为"可靠管道":

浏览访问网页,远程登录(SSH),MQTT/HTTP等协议

---

#### Linux下TCP编程过程

使用TCP编程时,需要做三件事:

1. **创建一个socket(套接字)**:

   socket是一个**内核对象**,行为类似文件描述符(fd)

   ```c
   int sockfd = socket(AF_INET, SOCK_STREAM, 0);
   ```

   `AF_INET` → IPv4

   `SOCK_STREAM` → TCP
   内核返回一个 fd → 类似文件的编号

2. **系统调用**


   > 通过相关功能函数来制定socket的行为

   **bind()**

   - 把socket挂接到某个IP:端口上,让内核知道要监听哪个端口

   **listen()**

   - 告诉内核维持一个半连接队列(SYN队列)和一个已连接队列(accept队列)
   - listen并不会阻塞,它只是上socket进入监听状态

   **accept()**

   > accpet负责创建真正的""通信管道""

   - 阻塞等待三次握手完成
   - 内核创建一个新的socket(专门用于与客户端通信)
   - 把这个新的socket的fd返回(客户端对应的连接通道)
   - 老socket用来监听
   - 新的socket用来通信

**socket() 创建的是一个“TCP 控制端口（监听句柄）”**
**connect/accept 才真正创建连接。**

3. **TCP三次握手与socket的关系**
   
   ![image-20251116180412890](../assets/image-20251116180412890.png)
   
   三次握手是内核自动处理的,不需要自己发包
   
   **简单示例:**
   
   server.c
   
   ```c
   #include <stdio.h>
   #include <string.h>
   #include <unistd.h>
   #include <arpa/inet.h>
   
   int main() {
       int listenfd = socket(AF_INET, SOCK_STREAM, 0);
   
       struct sockaddr_in addr;
       addr.sin_family = AF_INET;
       addr.sin_port = htons(8888);
       addr.sin_addr.s_addr = INADDR_ANY;
   
       bind(listenfd, (struct sockaddr*)&addr, sizeof(addr));
       listen(listenfd, 5);
   
       printf("Server listening on 8888...\n");
   
       while (1) {
           int connfd = accept(listenfd, NULL, NULL);
           printf("Client connected.\n");
   
           char buf[1024] = {0};
           int n = read(connfd, buf, sizeof(buf));
           printf("Recv: %s\n", buf);
   
           write(connfd, "Hello from server!", 19);
   
           close(connfd);
       }
   
       close(listenfd);
       return 0;
   }
   
   ```
   
   clinet.c
   
   ```c
   #include <stdio.h>
   #include <string.h>
   #include <unistd.h>
   #include <arpa/inet.h>
   
   int main() {
       int sockfd = socket(AF_INET, SOCK_STREAM, 0);
   
       struct sockaddr_in addr;
       addr.sin_family = AF_INET;
       addr.sin_port = htons(8888);
       inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);
   
       connect(sockfd, (struct sockaddr*)&addr, sizeof(addr));
   
       write(sockfd, "Hello server!", 13);
   
       char buf[1024];
       int n = read(sockfd, buf, sizeof(buf));
       printf("Recv: %s\n", buf);
   
       close(sockfd);
       return 0;
   }
   ```
   
   ---
   
   
   
#### TCP I/O机制

   > Linux下使用read()/write(),默认都是阻塞I/O

   **(1)read()**

   > 调用read有两个情况

   1. **如果内核缓冲区有数据->直接返回**

      对端已经write过,数据已到内核接收缓冲区(socket receive buffer)

      read()直接搬运数据到缓冲区,返回字节数

   2. **如果内核缓冲区没有数据->阻塞等待**

      等对端发送数据(或者异常,连接关闭,收到信号中断等情况)

**所以没有数据时,read不会空转,不会high CPU,它会睡眠等待内核的TCP模块唤醒它**

---



  **(2)wirte()**

1. write在内核发送缓冲区满时发送阻塞:

   - 对端接收得慢
   - 网络延迟大
   - 大量数据连续写
   - 内核tcp send buffer满

   此时write会挂起等待对端ACK释放buffer

---



  **(3)TCP是"字节流",不保证消息边界**

就是说

```lua
write(fd, "hello", 5);
write(fd, "world", 5);
```

对端可能收到

```ini
read = "helloworld"
#也可能
read = "hello"
read第二次="world"
#甚至
read = "hellow"
read第二次 = "orld"
```

上面情况称为粘包或半包(sticky/partial read)

分别对应**多条数据粘成了一条**和**一条数据被拆成了几段**的情况

根本原因是**TCP只保证字节序,不保证包边界**

应用write的速度快于对端的read,数据在网络层聚合成一块发送出去(MTU,MSS拥塞,导致网络层对数据进行拆解或聚合)

---

 **(4)粘包的解决方案**

1. 固定长度数据包(fixed length)

   - 简单但浪费空间,适合小型嵌入式协议

2. 使用分隔符(Delimiter)

   > 例如使用\n作为一条消息结束(HTTP header就是这样)

   - 实现简单
   - 但数据内容如果包含分隔符则需要转义

3. 包头+包体(header+body)

   > 例如`[4 字节长度][数据内容...]`,适用大部分情况

   - 先读4个字节,知道包体长度
   - 再读L字节,将整条消息读取出来

   **(5)read()半关闭**

​	`shutdown(fd, SHUT_WR)`内核发送FIN,告诉对端不会再发送数据,但是本端还可以继续接收

​	

​	read()返回值

| 返回值 | 含义                              |
| ------ | --------------------------------- |
| >0     | 收到字节数                        |
| 0      | 对端关闭写（FIN），连接可正常关闭 |
| -1     | 出错（可能 EINTR 或 EAGAIN）      |

---

#### TCP编程函数

##### **socket()**

创建一个内核网络对象(socket)并返回FD

```c
int socket(int domain, int type, int protocol)
```

**参数说明**

1. domain(协议簇)

   | 参数     | 作用                         |
   | -------- | ---------------------------- |
   | AF_INET  | IPv4                         |
   | AF_INET6 | IPv6                         |
   | AF_UNIX  | 本地进程间通信（用文件路径） |

2. type(通信语义),TCP指定**SOCK_STREAM**

   | type            | 含义              |
   | --------------- | ----------------- |
   | **SOCK_STREAM** | TCP，可靠字节流   |
   | SOCK_DGRAM      | UDP，不可靠数据报 |
   | SOCK_RAW        | 原始 IP 包        |

3. protocol(指定具体协议)

   通常填0,因为内核会根据domain+type自动选择

**socket()错误码**:

| 错误码 | 原因                             |
| ------ | -------------------------------- |
| EMFILE | 进程打开的 fd 数量到上限（1024） |
| ENFILE | 整个系统的 fd 到达上限           |
| EACCES | 权限不够（比如 raw socket）      |

**底层流程:**

1. 创建socket,socket是内核中的一个数据结构,负责:
   - 记录协议簇(AF_INET)
   - 记录类型(SOCK_STREAM)
   - TCP状态(CLOSED,SYN_SENT,ESTABLISHED...)
   - 发送/接收缓冲区(TCP缓冲区)
   - 对端地址
   - 本地地址+端口
   - 各种协议控制块(TCP控制卡tcp_sock)
   - 超时,重传,滑动窗口信息

​    可以将socket理解为是一个**网络端口状态机+缓冲区管理器**

2. 在当前进程的文件描述符表中,分配一个FD数字
   - 进程看到的是fd,又内核索引到socket对象
3. 根据AF_INET+SOCK_STREAM选择协议栈(TCP协议)
   - 如AF_INET->IPv4,SOCK_STREAM->tcp协议处理程序等协议栈
   - 最终socket会包含指向TCP协议栈的函数指针表(如connect->tcp_connect,send->tcp_sendmsg())
   - 所以调用write(fd),最终会走到tcp_sendmsg(),read同理,实现网络I/O像文件一样读写

**总结:socket() 是网络 I/O 的入口，创建一个 TCP/UDP 通道的控制对象，内核会为其分配缓冲区、状态机和协议控制逻辑。所有 read/write 最终都通过它进入 TCP 协议栈。**

---



##### bind()

bind()用于**把socket绑定到一个本地IP+端口**, 在内核中“占住某个本地 IP + 端口”，为**监听或通信做准备。**

为监听或通信做准备。

TCP连接由四元组唯一表示:

```
本地IP 本地端口
远端IP 远端端口
```

bind()把**本地IP,端口**固定下来

服务器需要一个**稳定端口**让客户端进行连接

所以服务器**必须bind()**

而客户端在连接时会自动选择随机的临时端口和默认的IP,所以通常不需要收到bind()

**函数原型**

```c
int bind(int sockfd, struct sockaddr* addr, int addrLen);
```

- sockfd: socket()函数返回的值
- addr: 指向sockaddr 结构体的指针,包含本机IP地址和端口号
- addrLen: 一般为`sizeof(sockaddr)`,即上面结构体的大小

**sockaddr结构体**

```c
struct sockaddr_in {
    sa_family_t    sin_family;   //地址族 AF_INET,2bytes
    unsigned short sin_port;     // 端口（网络字节序）,2bytes
    struct in_addr sin_addr;     // ip 地址,4bytes(IPv4)
};

struct in_addr
{
     in_addr_t  s_addr;  // u32 network address 
};
```

- sin_family: 地址族,一般为AF_INET指定IPv4
- sin_port: 端口 需要使用htons()转换成网络字节序`addr.sin_port = htons(8080);`

- sin_addr: IP地址,有两种写法,也需要转换字节序

  1. 绑定一个具体IP

     ```c
     inet_aton("192.168.1.10", &addr.sin_addr);
     ```

  2. 绑定`INADDR_ANY`

     ```c
     addr.sin_addr.s_addr = INADDR_ANY;  // 0.0.0.0
     //会绑定所有网卡的所有IPv4地址
     /*
     如果你机器有：
     192.168.1.10（WLAN）
     10.0.0.5（VPN）
     127.0.0.1（本地）
     INADDR_ANY 会让服务器同时监听这些地址。
     这是服务端最常用的写法。
     绑定的是当前机器的所有网卡
     外网能不能访问取决于防火墙,NAT而不是bind
     */
     ```

     

如果端口被占用,bind会失败

```perl
bind: Address already in use
```

使用setsockopt解决

bind()绑定本地地址

connect()设置远端地址

**底层操作**

1. 检查 socket 是否还没建立连接（TCP 状态必须是 CLOSED）

2. 检查端口是否被占用

3. 根据 bind 地址写入 tcp_sock 结构体

4. 插入到端口占用表（hash 表）

5. 将 socket 标记为“已绑定”

绑定成功后，listen 才能把它升级为监听 socket（LISTEN 状态）。

---



##### listen()

用于将套接字变成**监听**套接字,让内核接收客户端发来的SYN并处理

**函数原型**

```c
int listen(int sockfd, int backlog);
```

| 参数      | 含义                                                      |
| --------- | --------------------------------------------------------- |
| `sockfd`  | 已经通过 socket() 创建，并执行过 bind() 的 **TCP 套接字** |
| `backlog` | **允许同时排队的最大连接个数**（等待 accept() 的）        |

> listen()只能用语SOCK_STREAM(tcp)或SOCK_SEQPACKET
>
> UDP套接字调用会出错,因为UDP不需要连接队列

**backlog**

TCP连接过程中会涉及两个队列,blacklog决定了这两个队列的大小

1. **半连接队列(SYN queue)**
   - 客户端发送SYN
   - 内核应答SYN+ACK
   - 等待客户端发ACK的队列(即完成两次握手)
2. **全连接队列(Accpet queue)**
   - 三次握手完成
   - 套接字进入全连接队列
   - 等待程序调用accept

 在listen过程中,backlog实际上维护的是**全连接队列的最大长度**

 如果队列已满,新的TCP连接请求会被丢弃

**函数返回值**

| 返回值/错误码 | 解释                          |
| ------------- | ----------------------------- |
| 0             | 成功                          |
| -1            | 失败,并设置error              |
| EADDRINUSE    | 同端口已有监听者              |
| EINVAL        | 套接字未 bind 或不支持 listen |

总而言之:

**listen()让 TCP 套接字进入“监听模式”，并建立服务端连接队列，开始接受客户端的握手。没有 listen，就不可能 accept。**

---

##### accept()

**函数从内核的“全连接队列（accept queue）”取出一个已完成三次握手的连接，返回一个全新的 socket，用于与该客户端通信。**

**函数原型**

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

| 参数      | 意义                                       |
| --------- | ------------------------------------------ |
| `sockfd`  | listen() 过的监听套接字（被动套接字）      |
| `addr`    | 用于返回客户端的地址，如 IP、端口          |
| `addrlen` | 输入输出参数，传入结构体长度，返回实际大小 |

如果不关心客户端的地址可以写`accept(sockfd, NULL, NULL);`

返回值

| 情况 | 返回值                               |
| ---- | ------------------------------------ |
| 成功 | 返回一个新的文件描述符（主动套接字） |
| 失败 | -1，并设置 errno                     |

listen 的 socket 专门用于 accept

accept 返回的新 socket 用于通信

**底层操作**:

1. 三次握手完成后,内核会把该连接放入"全连接队列",accept从全连接队列取一个元素

   如果队列为空,accept行为取决于套接字是否阻塞

2. 如果阻塞(默认)

   会一直等待有客户端连接

3. 如果套接字是非阻塞模式

   程序继续执行,返回EAGAIN

  **错误码**

| errno                  | 意义                     |
| ---------------------- | ------------------------ |
| `EAGAIN`/`EWOULDBLOCK` | 非阻塞模式下，无连接可用 |
| `ECONNABORTED`         | 客户端在 accept 前断开   |
| `EMFILE`               | 进程文件描述符达到上限   |
| `ENFILE`               | 系统文件描述符达到上限   |
| `EFAULT`               | addr 无效                |
| `EINVAL`               | 未 listen 或类型不支持   |

**示例**

 ```c
 int sockfd = socket(AF_INET, SOCK_STREAM, 0);
 
 struct sockaddr_in addr;
 addr.sin_family = AF_INET;
 addr.sin_port = htons(8080);
 addr.sin_addr.s_addr = INADDR_ANY;
 
 bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
 
 listen(sockfd, 16);
 
 while (1) {
     struct sockaddr_in client;
     socklen_t len = sizeof(client);
 
     int cfd = accept(sockfd, (struct sockaddr*)&client, &len);
 
     printf("client connected: %s:%d\n",
            inet_ntoa(client.sin_addr),
            ntohs(client.sin_port));
 
     // 对 cfd 进行 recv/send…
 }
 
 ```



---

##### connect()

**让客户端发起 TCP 三次握手，并阻塞等待服务器回应。**

如果服务器接受并回复 SYN+ACK，则 connect 成功；
否则 connect 会返回错误。

**函数原型**

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

| 参数      | 作用                                      |
| --------- | ----------------------------------------- |
| `sockfd`  | 客户端的 socket（必须是 socket() 创建的） |
| `addr`    | 服务器地址（IP + port）                   |
| `addrlen` | 结构体大小                                |

**底层流程**

1. 客户端发送SYN段
   - 客户端开始建立连接
   - 内核发送SYN报文,记录下连接的初始状态
2. 服务端监听套接字收到SYN,将其放入半连接队列(SYN quque)
   - 服务端回应SYN+ACK
   - 客户端等待消息
3. 客户端发送ACK
   - 三次握手完成
4. connect()返回成功
   - connect成功说明双方完成三次握手
   - 但并不意味着之后不会通信失败

默认情况下,connect是阻塞的

connect会阻塞到三次握手完成

最终返回ETIMEOUT或ECONNREFUSED

**常见错误码**

| errno            | 解释                                       |
| ---------------- | ------------------------------------------ |
| **ECONNREFUSED** | 对方拒绝：目标端口没有 listen              |
| **ETIMEDOUT**    | 对方不回应：丢包、被防火墙挡住、服务器掉线 |
| **ENETUNREACH**  | 网络不可达                                 |
| **EHOSTUNREACH** | 目标主机不可达（ARP 不通）                 |
| **EINPROGRESS**  | 非阻塞 connect 正在尝试连接（下面讲）      |

connect不会排队,只是不断重试，直到成功或失败

此外TCP 标准规定：

客户端发送 SYN 后：

- 第一次重试间隔：3 秒
- 第二次：6 秒
- 第三次：12 秒
- 最多 3～5 次（和内核有关）

因此 connect 超时时间可能达到几十秒。

示例:

```c
int sock = socket(AF_INET, SOCK_STREAM, 0);

struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(8080);
inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);

if(connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
    perror("connect");
    exit(1);
}

printf("connected!\n");

```

---



##### I/O

> 简单介绍,与C语言I/O类似

**函数原型**

```c
ssize_t write(int fd, const void *buf, size_t count);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t read(int fd, void *buf, size_t count);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

send提供flags扩展功能,除此之外send和write行为完全相同

read和recv同理



---

#### UDP编程

1. 创建socket

   ```c
   int fd = socket(AF_INET, SOCK_DGRAM, 0);
   ```

2. 发送消息

   ```c
   ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                  const struct sockaddr *dest_addr, socklen_t addrlen);
   ```

   - 每次 sendto 是一个完整的数据包

   - 最长 65507 字节（IP 限制）

3. 接收消息

   ```c
   ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                    struct sockaddr *src_addr, socklen_t *addrlen);
   ```

   - 一次 recvfrom 读一个数据报

   - 如果你的 buf 小于发送的包 → 数据直接被截断（丢弃剩余部分）

总结

| 项目       | TCP           | UDP          |
| ---------- | ------------- | ------------ |
| 创建方式   | socket        | socket       |
| 绑定       | bind (server) | bind(server) |
| 监听       | listen        | ×            |
| 接受客户端 | accept        | ×            |
| 连接       | connect       | 可选         |
| 发送       | send/write    | sendto       |
| 接收       | recv/read     | recvfrom     |
| 消息边界   | 无            | 有           |
| 粘包问题   | 有            | 无           |
| 可靠性     | 高            | 低           |
