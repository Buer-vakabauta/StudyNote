## 一.网络基础

> 相关概念详见计算机网络

### 1.IP地址

互联网中的主机要与别的机器通信**必须具有一个IP地址**

IP地址为32位(IPv4)或者128位(IPv8)

每个数据包都必须携带目的IP地址或源IP地址,路由器依靠此信息为数据包选择路由

常用点分形式表示:

```
192.168.100.225
```

**IP地址的转换**

将strptr所指的字符串转换成32位的网络字节序二进制值

```c
#include <arpa/inet.h>
//将strptr所指的字符串转换成32位的网络字节序二进制值
int inet_aton(const char *strptr, struct in_addr *addrptr);
//功能同上,之间返回转换的值
int_addr_t inet_addr(const char *strptr);
////将二进制形式的IP地址转换为字符串形式
char *inet_ntoa(stuct in_addr inaddr);
///将IPv4/IPv6地址从文本转换为二进制形式
int inet_pton(int af, const char *src, void *dst);

```



```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    //将字符串形式的IP地址转换为二进制形式
    const char *ip_str = "192.168.30.1";
    struct in_addr ip_addr;
    if (inet_pton(AF_INET, ip_str, &ip_addr) != 1) {
        printf("Invalid IP address format\n");
        return 1;
    }
    printf("The binary representation of %s is: 0x%X\n", ip_str, ntohl(ip_addr.s_addr));
    //将字符串形式的IP地址转换为二进制形式（使用inet_addr）
    in_addr_t addr = inet_addr(ip_str);
    if (addr == INADDR_NONE) {
        printf("Invalid IP address format using inet_addr\n");
        return 1;
    }
    printf("The binary representation using inet_addr is: 0x%X\n", ntohl(addr));
    //将二进制形式的IP地址转换为字符串形式
    const char *ip=inet_ntoa(ip_addr);
    if (ip == NULL) {
        printf("Conversion to string failed\n");
        return 1;
    }
    printf("The string representation is: %s\n", ip);
    //将IPv4/IPv6地址从文本转换为二进制形式
    struct in6_addr ipv6_addr;
    const char *ipv6_str = "2001:0db8:85a3:0000:0000:8a2e:0370:7334";
    if (inet_pton(AF_INET6, ipv6_str, &ipv6_addr) != 1) {
        printf("Invalid IPv6 address format\n");
        return 1;
    }
    printf("The IPv6 address has been converted to binary form successfully.\n");
    return 0;
}
```



### 2.端口

为了区分一台主机接收到的数据包应该交给**哪个进程**来处理,使用**端口号**来区别

TCP端口号和UDP端口号独立

- 1~1023(1~255之间为众所周知端口号,256~1023端口通常有UNIX系统占用)
- 注册端口(1023~49150)
- 动态或私有端口(49151~65535)

### 3.Socket

socket(套接字)是网络编程中的一个抽象概念,它允许程序通过网络进行通信

可以将其看作是不同主机之间通信的端点,它提供了应用程序与网络协议栈之间的编程接口

在互联网上,程序之间通过IP地址和端口号组合成的唯一标识Socket来实现不同程序之间的数据交换

Socket可以分为**流式Socket**和**数据报Socket**:

**流式Socket**(SOCK_STREAM):

- 协议:TCP
- 面向连接,可靠
- 数据无差错,不丢失,不重复
- 按顺序到达
- 字节流传输

**数据包Socket**(SOCK_DGRAM)

- 协议UDP
- 无连接,不可靠
- 可能丢失,重复和乱序
- 有消息边界
- 效率高

也可以自己定义**原始Socket**(SOCK_RAW)

- 可以直接访问底层协议

- 用于自定义协议实现

### 4.字节序

不同类型CPU的主机中,内存存储多字节整数序列有两种方法,成为主机字节序(HBO)"

- 小端序:低序字节存储在低地址,将低字节存储在起始地址,
- 大端序:,高序字节存储在低地址,将高字节存储在起始地址

在网络传输中的数据必须按网络字节序,即大端字节序

**字节序转换**

**整数转换(用于端口等)**

主机字节序到网络字节序(host-to-net)

```c
u_long htonl (u_long hostlong);
u_short htons (u_short short);
```

网络字节序到主机之间序(net-to-host)

```c
u_long ntohl(u_long hostlong);
u_short ntohs (u_short short);
```

**字符串转换(用于IP地址等)**

```
inet_pton()
inet_ntop()
```

| 函数          | 作用                            | 使用场景                            |
| ------------- | ------------------------------- | ----------------------------------- |
| `htons()`     | 主机字节序转网络字节序（16 位） | 端口号设置（`bind()`，`connect()`） |
| `ntohs()`     | 网络字节序转主机字节序（16 位） | 端口号获取（`accept()`）            |
| `htonl()`     | 主机字节序转网络字节序（32 位） | IP 地址设置（`connect()`）          |
| `ntohl()`     | 网络字节序转主机字节序（32 位） | IP 地址获取（`accept()`）           |
| `inet_pton()` | IP 地址从字符串转为二进制       | `bind()`，`connect()`               |
| `inet_ntop()` | IP 地址从二进制转为字符串       | 打印 IP 地址（`accept()`）          |

---



  ## 二.TCP编程

TCP编程本质上是:

用C语言与Linux内核的 Socket 网络子系统交互,使两个进程(可以是同一台机器,也可以是不同机器)在可靠的双向字节流上通信

所以TCP很适合作为"可靠管道":

浏览访问网页,远程登录(SSH),MQTT/HTTP等协议

---

### Linux下TCP编程过程

使用TCP编程时,需要做三件事:

1. **创建一个socket(套接字)**:

   socket是一个**内核对象**,行为类似文件描述符(fd)

   ```c
   int sockfd = socket(AF_INET, SOCK_STREAM, 0);
   ```

   `AF_INET` → IPv4

   `SOCK_STREAM` → TCP
   内核返回一个 fd → 类似文件的编号

2. **系统调用**


   > 通过相关功能函数来制定socket的行为

   **bind()**

   - 把socket挂接到某个IP:端口上,让内核知道要监听哪个端口

   **listen()**

   - 告诉内核维持一个半连接队列(SYN队列)和一个已连接队列(accept队列)
   - listen并不会阻塞,它只是上socket进入监听状态

   **accept()**

   > accpet负责创建真正的""通信管道""

   - 阻塞等待三次握手完成
   - 内核创建一个新的socket(专门用于与客户端通信)
   - 把这个新的socket的fd返回(客户端对应的连接通道)
   - 老socket用来监听
   - 新的socket用来通信

**socket() 创建的是一个“TCP 控制端口（监听句柄）”**
**connect/accept 才真正创建连接。**

3. **TCP三次握手与socket的关系**
   
   ![image-20251116180412890](../assets/image-20251116180412890.png)
   
   三次握手是内核自动处理的,不需要自己发包
   
   **简单示例:**
   
   server.c
   
   ```c
   #include <stdio.h>
   #include <string.h>
   #include <unistd.h>
   #include <arpa/inet.h>
   
   int main() {
       int listenfd = socket(AF_INET, SOCK_STREAM, 0);
   
       struct sockaddr_in addr;
       addr.sin_family = AF_INET;
       addr.sin_port = htons(8888);
       addr.sin_addr.s_addr = INADDR_ANY;
   
       bind(listenfd, (struct sockaddr*)&addr, sizeof(addr));
       listen(listenfd, 5);
   
       printf("Server listening on 8888...\n");
   
       while (1) {
           int connfd = accept(listenfd, NULL, NULL);
           printf("Client connected.\n");
   
           char buf[1024] = {0};
           int n = read(connfd, buf, sizeof(buf));
           printf("Recv: %s\n", buf);
   
           write(connfd, "Hello from server!", 19);
   
           close(connfd);
       }
   
       close(listenfd);
       return 0;
   }
   
   ```
   
   clinet.c
   
   ```c
   #include <stdio.h>
   #include <string.h>
   #include <unistd.h>
   #include <arpa/inet.h>
   
   int main() {
       int sockfd = socket(AF_INET, SOCK_STREAM, 0);
   
       struct sockaddr_in addr;
       addr.sin_family = AF_INET;
       addr.sin_port = htons(8888);
       inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);
   
       connect(sockfd, (struct sockaddr*)&addr, sizeof(addr));
   
       write(sockfd, "Hello server!", 13);
   
       char buf[1024];
       int n = read(sockfd, buf, sizeof(buf));
       printf("Recv: %s\n", buf);
   
       close(sockfd);
       return 0;
   }
   ```
   
   ---
   
   
   

### TCP I/O机制

   > Linux下使用read()/write(),默认都是阻塞I/O

   **(1)read()**

   > 调用read有两个情况

   1. **如果内核缓冲区有数据->直接返回**

      对端已经write过,数据已到内核接收缓冲区(socket receive buffer)

      read()直接搬运数据到缓冲区,返回字节数

   2. **如果内核缓冲区没有数据->阻塞等待**

      等对端发送数据(或者异常,连接关闭,收到信号中断等情况)

**所以没有数据时,read不会空转,不会high CPU,它会睡眠等待内核的TCP模块唤醒它**

---



  **(2)wirte()**

1. write在内核发送缓冲区满时发送阻塞:

   - 对端接收得慢
   - 网络延迟大
   - 大量数据连续写
   - 内核tcp send buffer满

   此时write会挂起等待对端ACK释放buffer

---

  **(3)fcntl()**

​	当你一开始建立一个套接字描述符的时候,内核默认将其设置为阻塞IO模式(即上面提到的阻塞情况)

​	可以使用fcntl函数设置一个套接字的标志为`O_NOBLOCK`来实现非阻塞

     ```c
     int fcntl(int fd, int cmd, long arg);
     int flag；
     flag = fcntl(sockfd, F_GETFL, 0);//获取原有标志
     flag |= O_NONBLOCK;//在原有标志基础上添加O_NOBLOCK标志
     fcntl(sockfd, F_SETFL, flag);//设置新标志
     ```

​    应用程序会不停的访问内核来检查I/O是否就绪.这将是一个极其浪费CPU的操作

​	因此这种模式在使用中不普遍

---



  **(4)TCP是"字节流",不保证消息边界**

就是说

```lua
write(fd, "hello", 5);
write(fd, "world", 5);
```

对端可能收到

```ini
read = "helloworld"
#也可能
read = "hello"
read第二次="world"
#甚至
read = "hellow"
read第二次 = "orld"
```

上面情况称为粘包或半包(sticky/partial read)

分别对应**多条数据粘成了一条**和**一条数据被拆成了几段**的情况

根本原因是**TCP只保证字节序,不保证包边界**

应用write的速度快于对端的read,数据在网络层聚合成一块发送出去(MTU,MSS拥塞,导致网络层对数据进行拆解或聚合)

---

 **(5)粘包的解决方案**

1. 固定长度数据包(fixed length)

   - 简单但浪费空间,适合小型嵌入式协议

2. 使用分隔符(Delimiter)

   > 例如使用\n作为一条消息结束(HTTP header就是这样)

   - 实现简单
   - 但数据内容如果包含分隔符则需要转义

3. 包头+包体(header+body)

   > 例如`[4 字节长度][数据内容...]`,适用大部分情况

   - 先读4个字节,知道包体长度
   - 再读L字节,将整条消息读取出来

   **(6)read()半关闭**

​	`shutdown(fd, SHUT_WR)`内核发送FIN,告诉对端不会再发送数据,但是本端还可以继续接收

​	

​	read()返回值

| 返回值 | 含义                              |
| ------ | --------------------------------- |
| >0     | 收到字节数                        |
| 0      | 对端关闭写（FIN），连接可正常关闭 |
| -1     | 出错（可能 EINTR 或 EAGAIN）      |

### TCP编程函数

#### **socket()**

创建一个内核网络对象(socket)并返回FD

```c
int socket(int domain, int type, int protocol)
```

**参数说明**

1. domain(协议簇)

   | 参数     | 作用                         |
   | -------- | ---------------------------- |
   | AF_INET  | IPv4                         |
   | AF_INET6 | IPv6                         |
   | AF_UNIX  | 本地进程间通信（用文件路径） |

2. type(通信语义),TCP指定**SOCK_STREAM**

   | type            | 含义              |
   | --------------- | ----------------- |
   | **SOCK_STREAM** | TCP，可靠字节流   |
   | SOCK_DGRAM      | UDP，不可靠数据报 |
   | SOCK_RAW        | 原始 IP 包        |

3. protocol(指定具体协议)

   通常填0,因为内核会根据domain+type自动选择

**socket()错误码**:

| 错误码 | 原因                             |
| ------ | -------------------------------- |
| EMFILE | 进程打开的 fd 数量到上限（1024） |
| ENFILE | 整个系统的 fd 到达上限           |
| EACCES | 权限不够（比如 raw socket）      |

**底层流程:**

1. 创建socket,socket是内核中的一个数据结构,负责:
   - 记录协议簇(AF_INET)
   - 记录类型(SOCK_STREAM)
   - TCP状态(CLOSED,SYN_SENT,ESTABLISHED...)
   - 发送/接收缓冲区(TCP缓冲区)
   - 对端地址
   - 本地地址+端口
   - 各种协议控制块(TCP控制卡tcp_sock)
   - 超时,重传,滑动窗口信息

​    可以将socket理解为是一个**网络端口状态机+缓冲区管理器**

2. 在当前进程的文件描述符表中,分配一个FD数字
   - 进程看到的是fd,又内核索引到socket对象
3. 根据AF_INET+SOCK_STREAM选择协议栈(TCP协议)
   - 如AF_INET->IPv4,SOCK_STREAM->tcp协议处理程序等协议栈
   - 最终socket会包含指向TCP协议栈的函数指针表(如connect->tcp_connect,send->tcp_sendmsg())
   - 所以调用write(fd),最终会走到tcp_sendmsg(),read同理,实现网络I/O像文件一样读写

**总结:socket() 是网络 I/O 的入口，创建一个 TCP/UDP 通道的控制对象，内核会为其分配缓冲区、状态机和协议控制逻辑。所有 read/write 最终都通过它进入 TCP 协议栈。**

---



#### bind()

bind()用于**把socket绑定到一个本地IP+端口**, 在内核中“占住某个本地 IP + 端口”，为**监听或通信做准备。**

为监听或通信做准备。

TCP连接由四元组唯一表示:

```
本地IP 本地端口
远端IP 远端端口
```

bind()把**本地IP,端口**固定下来

服务器需要一个**稳定端口**让客户端进行连接

所以服务器**必须bind()**

而客户端在连接时会自动选择随机的临时端口和默认的IP,所以通常不需要收到bind()

**函数原型**

```c
int bind(int sockfd, struct sockaddr* addr, int addrLen);
```

- sockfd: socket()函数返回的值
- addr: 指向sockaddr 结构体的指针,包含本机IP地址和端口号
- addrLen: 一般为`sizeof(sockaddr)`,即上面结构体的大小

**sockaddr结构体**

```c
struct sockaddr_in {
    sa_family_t    sin_family;   //地址族 AF_INET,2bytes
    unsigned short sin_port;     // 端口（网络字节序）,2bytes
    struct in_addr sin_addr;     // ip 地址,4bytes(IPv4)
};

struct in_addr
{
     in_addr_t  s_addr;  // u32 network address 
};
```

- sin_family: 地址族,一般为AF_INET指定IPv4
- sin_port: 端口 需要使用htons()转换成网络字节序`addr.sin_port = htons(8080);`

- sin_addr: IP地址,有两种写法,也需要转换字节序

  1. 绑定一个具体IP

     ```c
     inet_aton("192.168.1.10", &addr.sin_addr);
     ```

  2. 绑定`INADDR_ANY`

     ```c
     addr.sin_addr.s_addr = INADDR_ANY;  // 0.0.0.0
     //会绑定所有网卡的所有IPv4地址
     /*
     如果你机器有：
     192.168.1.10（WLAN）
     10.0.0.5（VPN）
     127.0.0.1（本地）
     INADDR_ANY 会让服务器同时监听这些地址。
     这是服务端最常用的写法。
     绑定的是当前机器的所有网卡
     外网能不能访问取决于防火墙,NAT而不是bind
     */
     ```

     

如果端口被占用,bind会失败

```perl
bind: Address already in use
```

使用setsockopt解决

```c
int opt = 1;
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
//启用地址重用功能
//函数介绍
/*
listenfd (int sockfd)：
含义： 需要设置选项的套接字文件描述符。
SOL_SOCKET (int level)：
含义： 选项所在的协议族或级别。SOL_SOCKET 表示您正在设置的是套接字本身的通用选项，而不是某个特定协议（如 TCP 或 IP）的选项。
SO_REUSEADDR (int optname)：
含义： 需要设置的具体选项的名称。SO_REUSEADDR 允许本地地址和端口的重用。
&opt (const void *optval)：
含义： 指向存放选项值的缓冲区的指针。
这里指向一个整数 opt，其值为 1，表示启用此选项。如果值为 0，则表示禁用。
sizeof(opt) (socklen_t optlen)：
含义： 选项值缓冲区的大小。
既opt 变量（通常是 int 类型）的大小。
SO_REUSEADDR 的作用:
设置 SO_REUSEADDR 是网络编程中的一个常见操作，它解决了以下实际问题：
服务器重启快速绑定： 当服务器程序关闭后，其之前使用的端口通常会进入一个名为 TIME_WAIT 的状态（持续几分钟）。默认情况下，您无法立即将新的服务器进程绑定到同一个端口上。设置 SO_REUSEADDR 后，您可以立即重新绑定并重启服务器。
允许多个套接字绑定到同一地址（特定情况）： 在某些特定情况下（例如多播），允许多个套接字绑定到同一个端口。
*/
```

**底层操作**

1. 检查 socket 是否还没建立连接（TCP 状态必须是 CLOSED）

2. 检查端口是否被占用

3. 根据 bind 地址写入 tcp_sock 结构体

4. 插入到端口占用表（hash 表）

5. 将 socket 标记为“已绑定”

绑定成功后，listen 才能把它升级为监听 socket（LISTEN 状态）。

---



#### listen()

用于将套接字变成**监听**套接字,让内核接收客户端发来的SYN并处理

**函数原型**

```c
int listen(int sockfd, int backlog);
```

| 参数      | 含义                                                      |
| --------- | --------------------------------------------------------- |
| `sockfd`  | 已经通过 socket() 创建，并执行过 bind() 的 **TCP 套接字** |
| `backlog` | **允许同时排队的最大连接个数**（等待 accept() 的）        |

> listen()只能用语SOCK_STREAM(tcp)或SOCK_SEQPACKET
>
> UDP套接字调用会出错,因为UDP不需要连接队列

**backlog**

TCP连接过程中会涉及两个队列,`blacklog`决定了这两个队列的大小

1. **半连接队列(SYN queue)**
   - 客户端发送SYN
   - 内核应答SYN+ACK
   - 等待客户端发ACK的队列(即完成两次握手)
2. **全连接队列(Accpet queue)**
   - 三次握手完成
   - 套接字进入全连接队列
   - 等待程序调用accept

 在listen过程中,backlog实际上维护的是**全连接队列的最大长度**

 如果队列已满,新的TCP连接请求会被丢弃

**函数返回值**

| 返回值/错误码 | 解释                          |
| ------------- | ----------------------------- |
| 0             | 成功                          |
| -1            | 失败,并设置error              |
| EADDRINUSE    | 同端口已有监听者              |
| EINVAL        | 套接字未 bind 或不支持 listen |

总而言之:

**listen()让 TCP 套接字进入“监听模式”，并建立服务端连接队列，开始接受客户端的握手。没有 listen，就不可能 accept。**

**注意**:

1.**listen()只是设置socket的模式,并不会阻塞程序,内核中socket会一直接受来自客户端的请求,并放入队列交给后续accept来处理**

2.**全连接队列中都是已经三次握手完成的队列**,**半连接队列是正在进行三次握手的连接**

3.**全连接队列中已经accept(完成三次握手的请求)会被移除,`BACKLOG`表示的是允许同时连接的最大客户端数量**



---

#### accept()

**函数从内核的“全连接队列（accept queue）”取出一个已完成三次握手的连接，返回一个全新的 socket，用于与该客户端通信。**

**函数原型**

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

| 参数      | 意义                                       |
| --------- | ------------------------------------------ |
| `sockfd`  | listen() 过的监听套接字（被动套接字）      |
| `addr`    | 用于返回客户端的地址，如 IP、端口          |
| `addrlen` | 输入输出参数，传入结构体长度，返回实际大小 |

如果不关心客户端的地址可以写`accept(sockfd, NULL, NULL);`

返回值

| 情况 | 返回值                               |
| ---- | ------------------------------------ |
| 成功 | 返回一个新的文件描述符（主动套接字） |
| 失败 | -1，并设置 errno                     |

listen 的 socket 专门用于 accept

accept 返回的新 socket 用于通信

**底层操作**:

1. 三次握手完成后,内核会把该连接放入"全连接队列",accept从全连接队列取一个元素

   如果队列为空,accept行为取决于套接字是否阻塞

2. 如果阻塞(默认)

   会一直等待有客户端连接

3. 如果套接字是非阻塞模式

   程序继续执行,返回EAGAIN

  **错误码**

| errno                  | 意义                     |
| ---------------------- | ------------------------ |
| `EAGAIN`/`EWOULDBLOCK` | 非阻塞模式下，无连接可用 |
| `ECONNABORTED`         | 客户端在 accept 前断开   |
| `EMFILE`               | 进程文件描述符达到上限   |
| `ENFILE`               | 系统文件描述符达到上限   |
| `EFAULT`               | addr 无效                |
| `EINVAL`               | 未 listen 或类型不支持   |

**示例**

 ```c
 int sockfd = socket(AF_INET, SOCK_STREAM, 0);
 
 struct sockaddr_in addr;
 addr.sin_family = AF_INET;
 addr.sin_port = htons(8080);
 addr.sin_addr.s_addr = INADDR_ANY;
 
 bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
 
 listen(sockfd, 16);
 
 while (1) {
     struct sockaddr_in client;
     socklen_t len = sizeof(client);
 
     int cfd = accept(sockfd, (struct sockaddr*)&client, &len);
 
     printf("client connected: %s:%d\n",
            inet_ntoa(client.sin_addr),
            ntohs(client.sin_port));
 
     // 对 cfd 进行 recv/send…
 }
 
 ```



---

#### connect()

**让客户端发起 TCP 三次握手，并阻塞等待服务器回应。**

如果服务器接受并回复 SYN+ACK，则 connect 成功；
否则 connect 会返回错误。

**函数原型**

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

| 参数      | 作用                                      |
| --------- | ----------------------------------------- |
| `sockfd`  | 客户端的 socket（必须是 socket() 创建的） |
| `addr`    | 服务器地址（IP + port）                   |
| `addrlen` | 结构体大小                                |

**底层流程**

1. 客户端发送SYN段
   - 客户端开始建立连接
   - 内核发送SYN报文,记录下连接的初始状态
2. 服务端监听套接字收到SYN,将其放入半连接队列(SYN quque)
   - 服务端回应SYN+ACK
   - 客户端等待消息
3. 客户端发送ACK
   - 三次握手完成
4. connect()返回成功
   - connect成功说明双方完成三次握手
   - 但并不意味着之后不会通信失败

默认情况下,connect是阻塞的

connect会阻塞到三次握手完成

最终返回ETIMEOUT或ECONNREFUSED

**常见错误码**

| errno            | 解释                                       |
| ---------------- | ------------------------------------------ |
| **ECONNREFUSED** | 对方拒绝：目标端口没有 listen              |
| **ETIMEDOUT**    | 对方不回应：丢包、被防火墙挡住、服务器掉线 |
| **ENETUNREACH**  | 网络不可达                                 |
| **EHOSTUNREACH** | 目标主机不可达（ARP 不通）                 |
| **EINPROGRESS**  | 非阻塞 connect 正在尝试连接（下面讲）      |

connect不会排队,只是不断重试，直到成功或失败

此外TCP 标准规定：

客户端发送 SYN 后：

- 第一次重试间隔：3 秒
- 第二次：6 秒
- 第三次：12 秒
- 最多 3～5 次（和内核有关）

因此 connect 超时时间可能达到几十秒。

示例:

```c
int sock = socket(AF_INET, SOCK_STREAM, 0);

struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(8080);
inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);

if(connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
    perror("connect");
    exit(1);
}

printf("connected!\n");

```

---

#### close/shutdown

```c
int close(int sockfd); //关闭双向通讯
int shutdown(int sockfd, int howto);
```

TCP连接是双向的(是可读写的)，当我们使用close时,会把读写通道都关闭，有时侯我们希望只关闭一个方向，这个时候我们可以使用shutdown。

针对不同的howto，系统回采取不同的关闭方式。

- `howto = 0`
  关闭读通道，但是可以继续往套接字写数据。
- `howto = 1`
  和上面相反，关闭写通道。只能从套接字读取数据。
- `howto = 2`
  关闭读写通道，和close()一样

---





#### I/O

> 简单介绍,与C语言I/O类似

**函数原型**

```c
ssize_t write(int fd, const void *buf, size_t count);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t read(int fd, void *buf, size_t count);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

send提供flags扩展功能,除此之外send和write行为完全相同

read和recv同理

**注意**

**recv不会给字符串终止符,需要手动加'\0'时注意避免数组越界**

```c
ssize_t bytes_received=recv(clientfd,buffer,sizeof(buffer)-1,0);//这里提前-1避免后面+"\0"时数组越界
buffer[bytes_received]='\0'; //确保字符串终止,消息越界
```



---

#### 示例

实现多线程的tcp通信,使用信号量维护客户端数量

server.c

```c
//tcp_server.c
//linux 
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <semaphore.h>

#define IPADDR "127.0.0.1"
#define PORT 8080
#define BACK_LOG 3
#define MAXCLIENTS 3
#define EXIT_CMD "exit"
//线程处理函数



void* pthread_client_handle(void* arg);//客户端处理函数
sem_t empty_slots;//空闲连接槽位数


int main(){
    //初始化信号量
    sem_init(&empty_slots,0,MAXCLIENTS);
    //存储信号量值
    int num =0;
    //socket创建
    int serverfd=socket(AF_INET,SOCK_STREAM,0);
    if(serverfd==-1){
        perror("socket creation failed");
        return -1;
    }
    printf("Socket created successfully with fd: %d\n", serverfd);
    //bind绑定
    struct sockaddr_in server_addr;
    server_addr.sin_family=AF_INET;
    inet_pton(AF_INET,IPADDR,&server_addr.sin_addr);
    server_addr.sin_port=htons(PORT);
    if(bind(serverfd,(struct sockaddr*)&server_addr,sizeof(server_addr))<0){
        perror("bind failed");
        return -1;
    }
    printf("Socket bound to port 8080\n");
    //设置监听
    if(listen(serverfd,BACK_LOG)<0){
        perror("listen failed");
        return -1;
    }
    printf("Set socket listen mode\n");
    //多线程接受
    
    while (1)
    {   
        sem_getvalue(&empty_slots,&num);
        if(num<=0){
            printf("Maximum client limit reached. No longer accepting new connections.\n");
        }
        //等待信号量资源
        sem_wait(&empty_slots);

        //客户端ip
        struct sockaddr_in client_addr;
        socklen_t client_addr_len=sizeof(client_addr);
        //accept接受连接
        int clientfd=accept(serverfd,(struct sockaddr*)&client_addr,&client_addr_len);
        if (clientfd<0){
            perror("accept failed");
            continue;
        }
        char client_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET,&client_addr.sin_addr,client_ip,sizeof(client_ip));
        printf("Accepted connection from %s:%d\n",client_ip,ntohs(client_addr.sin_port));
        //创建线程处理客户端请求
        pthread_t tid;
        pthread_create(&tid,NULL,pthread_client_handle,(void*)(intptr_t)clientfd);//使用intptr_t保证安全(指针大小可能不等于int大小)
    }
    
    

}
//客户端处理函数
void* pthread_client_handle(void* arg){
    //获取客户端id
    int clientfd=(int)(intptr_t)arg;
    //定义消息缓冲区
    char buffer[1024];
    while (1){
        //接收客户端消息
        ssize_t bytes_received=recv(clientfd,buffer,sizeof(buffer)-1,0);//recv不会给字符串终止符,这里提前-1避免后面+"\0"时数组越界
        if(bytes_received<0){perror("recv failed");break; }
        else if(bytes_received==0){printf("Client disconnected\n");}
        buffer[bytes_received]='\0'; //确保字符串终止
        printf("Received from client %d: %s\n",clientfd,buffer);
        if(strcmp(buffer,EXIT_CMD)==0){
            printf("Client %d sent exit command. Closing connection.\n",clientfd);
            break;
        }
        //发送响应给客户端
        const char* response="Message received";
        ssize_t bytes_sent=send(clientfd,response,strlen(response),0);
        if(bytes_sent<0){perror("send failed");break;}
        //客户端异常
    }
    close(clientfd);
    sem_post(&empty_slots); //释放一个信号量槽位
}

```

client.c

```c
//tcp_client.c
//linux 
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <semaphore.h>

#define IPADDR "127.0.0.1"
#define PORT 8080
#define BACK_LOG 3
#define MAXCLIENTS 3
#define EXIT_CMD "exit"

int main(){
    //创建socket
    int clientfd=socket(AF_INET,SOCK_STREAM,0);
    if(clientfd==-1){
        perror("socket creation failed");
        return -1;
    }
    printf("Socket created successfully with fd: %d\n", clientfd);
    //服务器地址结构体
    struct sockaddr_in server_addr;
    server_addr.sin_family=AF_INET;
    inet_pton(AF_INET,IPADDR,&server_addr.sin_addr);
    server_addr.sin_port=htons(PORT);
    //连接服务器
    if(connnect(clientfd,(struct sockaddr*)&server_addr,sizeof(server_addr))<0){
        perror("connect failed");
        return -1;
    }
    //通信
    char send_buf[1024];
    char recv_buf[1024];
    printf("Connected to server %s:%d\n",IPADDR,PORT);
    printf("Input message to send to server:\n");
    
    while (1)
    {
        scanf("%s",send_buf);
        send(clientfd,send_buf,strlen(send_buf),0);
        if(strcmp(send_buf,EXIT_CMD)==0){
            printf("Exiting...\n");
            close(clientfd);
            break;
        }

    }
}
```

### UDP编程

1. 创建socket

   ```c
   int fd = socket(AF_INET, SOCK_DGRAM, 0);
   ```

2. 发送消息

   ```c
   ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                  const struct sockaddr *dest_addr, socklen_t addrlen);
   ```

   - 每次 sendto 是一个完整的数据包

   - 最长 65507 字节（IP 限制）

3. 接收消息

   ```c
   ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                    struct sockaddr *src_addr, socklen_t *addrlen);
   ```

   - 一次 recvfrom 读一个数据报

   - 如果你的 buf 小于发送的包 → 数据直接被截断（丢弃剩余部分）

总结

| 项目       | TCP           | UDP          |
| ---------- | ------------- | ------------ |
| 创建方式   | socket        | socket       |
| 绑定       | bind (server) | bind(server) |
| 监听       | listen        | ×            |
| 接受客户端 | accept        | ×            |
| 连接       | connect       | 可选         |
| 发送       | send/write    | sendto       |
| 接收       | recv/read     | recvfrom     |
| 消息边界   | 无            | 有           |
| 粘包问题   | 有            | 无           |
| 可靠性     | 高            | 低           |

---



### 多路复用IO

[前面提到](#TCP I/O机制)在使用TCP进行通信时,使用read/recv会阻塞导致其他客户端不能及时处理信息

一个想法是使用多线程,一个客户端一个线程(如前面[示例](#示例)中所使用的方法)

但是在需要大量并发的场景需要启动大量的线程,导致CPU频繁启用调度,极其浪费CPU资源

为了应对上面场景,比较好的方法就是使用IO多路复用

基本思想:让一个线程同时监控多个socket哪个socket有数据就处理哪个

其他不活跃的socket不会阻塞线程

多路复用IO不是让read()不阻塞,而是在read之前判断socket是否可读再来决定去不去read()

Linux针对多路复用IO提供了三种方案

按时间顺序:

select->poll->epoll

下面主要介绍select和epoll

---

#### select

*函数原型*

```c
#include <sys/select.h>

int select(int nfds,
           fd_set *readfds,
           fd_set *writefds,
           fd_set *exceptfds,
           struct timeval *timeout);
```

| 参数      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| nfds      | 所有要监控文件的**fd**中**最大**的那一个**再+1**             |
| readfds   | 要监视的可读文件的`fd`的集合                                 |
| writefds  | 要监视的可写文件的`fd`的集合                                 |
| exceptfds | 其他要向我们通知的文件描述符<br />用于监视异常事件(一般很少用) |
| timeout   | 超时设置<br />NULL:一直阻塞<br />{0,0}:立即返回<br />不为0的时间值:在指定时间内,如果没有事件发生,则超时返回 |

***fd_set***

select参数中的集合均使用fd_set

内核要求fd_set是位图,每个fd占一个bit

为了方便用户,提供了一下宏操作:

```c
FD_ZERO(fd_set *set);        // 清空集合中的所有fd
FD_SET(int fd, fd_set *set); // 添加 fd到set
FD_CLR(int fd, fd_set *set); // 从集合中移除fd
FD_ISSET(int fd, fd_set *set);// 判断fd是否在集合中
```

***select函数功能***

**select返回后,fd_set会被修改,只保留有事件的fd**

也就是说

- 事件没发生的fd会被自动移除

- 每次调用select前要重新FD_SET

**使用流程**:

(1)创建fd_set

```c
fd_set readfds;
FD_ZERO(&readfds);
FD_SET(listenfd, &readfds);
FD_SET(connfd, &readfds);
```

(2)调用select

select进入内核,扫描fd0~nfds-1的每一位

直到有事件发生或者timeout到期

(3)select返回

没集合中没有事件的fd清除掉

(4)使用FD_ISSET来判断事件是否有事件

**select缺陷**

1. select最多只能监视1024个fd

2. 每次调用都要复制fd_set到内核,开销大
3. 每次select后需要重新填fd_set,操作麻烦

**示例**

TCP相关内容略

```c
int listenfd = socket(...);
bind(listenfd, ...);
listen(listenfd, SOMAXCONN);

fd_set allset, rset;
FD_ZERO(&allset);
FD_SET(listenfd, &allset);

int maxfd = listenfd;

while (1) {
    rset = allset; // 拷贝备用

    int nready = select(maxfd + 1, &rset, NULL, NULL, NULL);

    if (FD_ISSET(listenfd, &rset)) {
        int connfd = accept(listenfd, NULL, NULL);
        FD_SET(connfd, &allset);
        if (connfd > maxfd) maxfd = connfd;
    }

    for (int fd = 0; fd <= maxfd; fd++) {
        if (fd != listenfd && FD_ISSET(fd, &rset)) {
            int n = read(fd, buf, sizeof(buf));
            if (n <= 0) {
                close(fd);
                FD_CLR(fd, &allset);
            } else {
                write(fd, buf, n);
            }
        }
    }
}
```

---

#### epoll

epoll的设计目标是解决select/poll的效率瓶颈:

- select/poll每次调用都把整个fd列表从用户态复制到内核态,且内核扫描每个fd

epoll在内核维护两套结构:

- interest list(关注列表):由`epoll_ctl`填充,类似要监视的`fd集合`
- ready list(就绪链表):内核在fd有事件时把它加入到一个就绪链表,`epoll_wait`只取就绪链表里的条目,避免每次扫全表

**函数**

epoll操作需要三个接口:

```c
int epoll_create(int size)；//旧AIP,创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
int epoll_create1(int flags);// 推荐：flags 可用 EPOLL_CLOEXEC
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

- `int epoll_create(int sieze)`

  创建一个`epoll`的句柄,`size`用来告诉内核这个监听的数目有多大,该参数不会限制epoll所能监听描述符的最大个数,只是对内核初始分配内部数据结构的一个建议

  当创建好epoll句柄后,会返回一个fd值

- `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)`；

  对指定描述符fd执行增减操作

  `epfd`:是epoll_create()的返回值

  `op`:表示op操作,用三个宏来表示`POLL_CTL_ADD`,`POLL_CTL_DEL`,`POLL_CTL_MOD`分别表示添加删除和修改

  `epoll_event`:告诉内核需要监听的事件

- `int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)`

  等待epfd上的IO事件,最多返回maxevents个事件

  `events`用来从内核得到时间的集合,`maxevents`告知内核这个events有多大

  `maxevents`不能大于创建`epoll_create`时的size

  `timeout`是超时时间(ms,0立即返回,-1永久阻塞)

  函数返回需要处理的事件数目,返回0时则表示已经超时

**相关结构体**

```c
struct epoll_event {
    uint32_t events;    // EPOLLIN, EPOLLOUT, EPOLLERR, EPOLLHUP, EPOLLET, EPOLLONESHOT...
    epoll_data_t data;  // 用户数据联合体（通常放 fd 或 指针）
    //在某些高级用法(例如使用指针将自定义数据结构与文件描述符相关联)会用到指针
    //因此在epoll_ctl中仍然需要显式的传入socketfd
};
```

events可以是以下几个宏的集合

`EPOLLIN` ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
`EPOLLOUT`：表示对应的文件描述符可以写(不会阻塞)；
`EPOLLPRI`：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
`EPOLLERR`：表示对应的文件描述符发生错误；
`EPOLLHUP`：表示对应的文件描述符被挂断；
`EPOLLET`： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
`EPOLLONESHOT`：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里

`epll_data_t data`用法:

```c
event.data.fd = fd;         // 或者
event.data.ptr = ptr;       // 指向连接结构体
```



注意:

- `EPOLLIN`/`EPOLLOUT` 与 `EPOLLERR`/`EPOLLHUP` 常常会同时出现。不要只判断 `EPOLLIN`，忽略 `EPOLLERR|EPOLLHUP`。
- `EPOLLIN` 被触发也可能是“对端关闭并且无数据”（读返回0），你的处理逻辑要能区分并关闭连接。

**事件触发模式**

1. Level-Triggered(LT,默认模式)
   - 水平触发语义和`select`一样:只要fd是"可读/写"的状态,每次`epoll_wait`都会返回该fd
   - 简单、健壮：每次处理时不必把缓冲区读空 — 如果没读完，下次 `epoll_wait` 依然会告知你。
2. Edge-Triggered(ET,使用EPOLLET标志)
   - 边沿触发:只有在事件从无到有(状态变化)那一刻,内核才把fd放入ready list并唤醒`epoll_wait`
   - 如果没有把数据全部读/写干净,就不会再次收到通知(除非又发生新的状态变化)
   - 因此ET必须使用非阻塞socket,并且在收到可读/可写事件时循环读/写知道返回EAGAIN/EWOULDBLOCK以清空缓冲区或填满缓冲区
   - ET优点:较少唤醒,性能更好,适合需要高并发吞吐的情况(连接很多)

**使用流程**

1. 创建epoll

   ```c
   int epfd = epoll_create1(EPOLL_CLOEXEC);
   ```

2. 把监听socket设置为非阻塞(使用ET时)

   ```c
   set_nonblocking(listenfd);//可使用前面提到的fcntl来实现
   ```

3. 注册监听socket到epoll(通常希望检测EPOLLIN)

   ```c
   struct epoll_event ev;
   ev.events=EPOLLIN;
   ev.data.fd=listen;
   epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&ev);
   ```

4. 循环使用`epoll_wait`获取就绪事件数组:

   ```c
   struct epoll_event events[MAX_EVENTS];
   int n = epoll_wait(epfd, events, MAX_EVENTS, -1);
   for (i = 0; i < n; ++i) {
       // 处理 events[i]
   }
   ```

5. 对于新连接（listenfd 可读）：

   - accept 循环接收所有可用连接（如果使用 ET 必须循环 accept 直到返回 EAGAIN）
   - 新 connfd 设为非阻塞并 `epoll_ctl(ADD)` 注册（EPOLLIN | maybe EPOLLET）

6. 对于已连接 socket（events[i]）：

   - 若 EPOLLIN：循环 `read()` 直到返回 EAGAIN（ET）或读完（LT 可逐次读）
   - 若 EPOLLOUT：循环 `write()` 直到写完或返回 EAGAIN
   - 处理 EPOLLERR/EPOLLHUP：关闭 fd

	##### epoll示例

> Listen+epoll(ET)+非阻塞socket+accept循环+read循环

`epoll_et_server.c`

```c
// epoll_et_server.c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <netinet/in.h>

#define PORT 8080
#define MAX_EVENTS 1024
#define BACKLOG 128
#define BUF_SIZE 4096

static int set_nonblocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) return -1;
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) return -1;
    return 0;
}//定义函数实现来实现socket的非阻塞




int main() {
    int listenfd, epfd;//定义监听socket和epoll fd
    struct sockaddr_in addr;

    listenfd = socket(AF_INET, SOCK_STREAM, 0);//创建套接字
    int opt = 1;//设置选项为启用
    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));//启用地址重用功能

    //配置地址项
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;//IPv4
    addr.sin_port = htons(PORT);//端口
    addr.sin_addr.s_addr = INADDR_ANY;//IP设置为监听所有

    bind(listenfd, (struct sockaddr*)&addr, sizeof(addr));//配置到socket
    listen(listenfd, BACKLOG);//启用监听模式

    // 非阻塞监听 socket（ET 情况下必须）
    set_nonblocking(listenfd);//设置非阻塞,accept不会再阻塞

    //epoll操作
    epfd = epoll_create1(0);//创建间epfd
    if (epfd == -1) { perror("epoll_create1"); exit(1); }//错误处理

    struct epoll_event ev;
    ev.events = EPOLLIN | EPOLLET; // 监听可读（新连接）并使用 ET
    ev.data.fd = listenfd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &ev);//添加监听事件到ev

    struct epoll_event *events = calloc(MAX_EVENTS, sizeof(struct epoll_event));

    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);
        if (n < 0) {
            if (errno == EINTR) continue;
            perror("epoll_wait");
            break;
        }

        for (int i = 0; i < n; i++) {
            int fd = events[i].data.fd;
            uint32_t evs = events[i].events;

            if (fd == listenfd) {
                // 必须循环 accept，直到 EAGAIN
                while (1) {
                    struct sockaddr_in cli;
                    socklen_t len = sizeof(cli);
                    int connfd = accept(listenfd, (struct sockaddr*)&cli, &len);
                    if (connfd < 0) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            // 全部 accept 完成
                            break;
                        } else {
                            perror("accept error");
                            break;
                        }
                    }
                    
					//将新连接加入epoll
                    set_nonblocking(connfd);//设置非阻塞

                    struct epoll_event cev;
                    cev.events = EPOLLIN | EPOLLET; // 对连接使用 ET
                    cev.data.fd = connfd;
                    epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &cev);

                    char ip[INET_ADDRSTRLEN];
                    inet_ntop(AF_INET, &cli.sin_addr, ip, sizeof(ip));
                    printf("Accepted %s:%d fd=%d\n", ip, ntohs(cli.sin_port), connfd);
                }
            } else {
                // 处理已连接 fd（ET 模式）
                if (evs & (EPOLLERR | EPOLLHUP)) {
                    // 错误或挂起：关闭 fd
                    fprintf(stderr, "fd %d error/hup\n", fd);
                    close(fd);
                    continue;
                }

                if (evs & EPOLLIN) {
                    // 必须循环读取直到 EAGAIN
                    while (1) {
                        char buf[BUF_SIZE];
                        ssize_t cnt = read(fd, buf, sizeof(buf));
                        if (cnt == -1) {
                            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                                // 数据读完
                                break;
                            } else {
                                perror("read");
                                close(fd);
                                break;
                            }
                        } else if (cnt == 0) {
                            // 对端关闭
                            printf("fd %d closed by peer\n", fd);
                            close(fd);
                            break;
                        } else {
                            // 处理数据（打印接收数据）
                            printf("Received Msg from fd %d:%.*s\n",fd,(int)cnt,buf);
                        }
                    }
                }
                // 如果需要处理 EPOLLOUT，可在此加入逻辑
            }
        }
    }
	//释放
    free(events);
    close(epfd);
    close(listenfd);
    return 0;
}
```

---

---



## 三.网络分析



