硬件使用树莓派5

主要介绍ARMv8-A(AArch64)

## 计算机组成与arm处理器

> 对相关概念解释,CPU、总线、寄存器、地址映射等,能知道驱动到底在和谁交互

---

### 计算机基础

> 只简单介绍对后面内容比较重要的概念,详见计算机组成原理

#### **基础设备**

1. **总线**

   总线是计算机中各个部件之间传送信息的公共通信干线

   在物理上就是一束导线

   按照其传递信息的类型可以分为数据总线 地址总线 控制总线

   DMA(Direct Memory Access)即直接存储器访问，使用DMA总线可以不通过CPU直接在存储器之间进行数据传递

2. 输入设备

   把其他信号转换成计算机能识别和处理的信号并送入计算机中
   如键盘、鼠标、摄像头等

3. 输出设备

   把运算结果以人或其他设备所能接受的形式送出计算机外
   如显示器、音响、打印机等

4. 存储器

   存储器是用来存储程序和数据的部件,是实现"存储程序控制"的基础
   如内存、硬盘等

5. 运算器

   CPU中负责进行算数运算和逻辑运算的部件，其核心是算术逻辑单元ALU

#### **存储结构与地址空间**

1. Cache(高速缓存)

   速度最快、价格最贵、容量最小、断电数据丢失、cpu可直接访问
   存储当前正在执行的程序中的活跃部分,以便快速地向CPU提供指令和数据

2. 主存储器(RAM)

   速度、价格、容量介于Cache与辅存之间、断电数据丢失、cpu可直接访问
   存储当前正在执行的程序和数据

3. 辅助存储器(ROM)

   速度最慢、价格最低、容量最大、断电数据不丢失、cpu不可直接访问
   存储暂时不运行的程序和数据，需要时再传送到主存

4. 地址空间

   一个处理器能够访问（读写）的存储空间是有限的,我们称这个空间为它的地址空间（寻址空间）,一般来说`N位`地址总线的处理器的地址空间是2的N次方

#### **驱动**程序

驱动程序（Device Driver）是一种特殊的内核程序，它充当操作系统内核与硬件设备之间的通信桥梁。

本质上就是一段代码实现通过总线→找到设备→操作寄存器→控制硬件

**核心功能**

- **硬件抽象与封装：** 驱动程序将特定硬件的操作细节隐藏起来，提供一组统一、标准的接口（例如文件操作接口 `open`, `read`, `write`, `close` 等）给内核和应用程序使用。
- **实现操作系统指令到硬件操作的转换：** 当应用程序发出一个系统调用（如读取数据）时，内核会将这个请求转交给相应的驱动程序。驱动程序负责将这些高级指令转换为特定硬件能够理解和执行的低级指令（例如向硬件寄存器写入数据、发送控制信号等）。
- **管理硬件资源：** 驱动程序负责设备的初始化、资源的分配与释放（如内存映射、中断请求号 IRQ、DMA 通道等）、错误处理以及数据传输等任务。



#### 外设

外设（Peripheral Device），全称外部设备或周边设备，是指连接到计算机主机外（或内部通过接口连接而非核心部件）的、能够扩展计算机功能的所有硬件设备。

外设要能在Linux中正常工作,必须依赖相应的驱动程序

**交互过程**

1. **应用程序发出系统调用**
2. **Linux内核**(通过**设备驱动程序**)向外设控制器的命令寄存器写入指令
3. **设备控制器**读取命令,并控制**设备本体**执行动作
4. 数据被捕获或生成后,临时存入缓冲区
5. **控制器**更新**状态寄存器**，并通常通过**中断**通知 CPU 数据已准备好。
6. 驱动程序协调数据从缓冲区传输到主机内存（有时使用 **DMA** 直接内存访问技术），最终到达应用程序。

#### 内存映射IO

CPU通过MMIO(Memory-Mapped I/O)内存映射IO来访问外设寄存器

用户态程序是不能直接访问设备地址的(出于系统安全性考虑)

外设寄存器被映射成一段内存地址,使CPU像访问内存一样访问外设



例如:

```nginx
GPIO 控制寄存器地址 = 0xFE200000
```

那么驱动里就会写

```c
*(volatile unsigned int *)(0xFE200000) = 0x1;   // 设置 GPIO 输出
```

---

### ARM基础

arm是一类处理器的统称

- 早期经典处理器

  ARM7/9/11等

- Cortex-A系列

  针对开放式操作系统的高性能处理器

  应用于智能手机,数据电视等高端应用

- Cortex-R系列

  针对实时系统,满足实时性的控制要求

  应用于汽车制动系统,动力系统等

- Cortex-M系列

  为单片机驱动的系统提供了低成本的优化方案

  应用于传统的微控制器市场、智能传感器、汽车周边等

#### ARM指令集概述

**指令**

- 能够指示处理器执行某种运算的命令称为指令（如加、减、乘 …）
- 指令在内存中以机器码（二进制）的方式存在
- 每一条指令都对应一条汇编
- 程序是指令的有序集合

**指令集**

- 处理器能识别的指令的集合称为指令集
- 不同架构的处理器指令集不同
- 指令集是处理器对开发者提供的接口

**ARM指令集**

- 所有指令（机器码）都占用32bit存储空间
- 代码灵活度高、简化了解码复杂度
- 执行ARM指令集时PC(寄存器)值每次自增4

**Thumb指令集**

所有指令（机器码）都占用16bit存储空间
代码密度高、节省存储空间
执行Thumb指令集时PC值每次自增2

#### ARM存储模型

**ARM数据类型**

- ARM采用32位架构，基本数据类型有以下三种
  - Byte : `8bits`
  - Halfword : `16bits`
  - Word : `32bits`
- 数据存储
  Word型数据在内存的起始地址必须是`4的整数倍`
  Halfword型数据在内存的起始地址必须是`2的整数倍`

**字节序**

- `大端对齐 - 低对高`
  低地址存放高位，高地址存放低位
- `小端对齐 - 低对低`
  低地址存放低位，高地址存放高位

ARM一般使用小端对齐



**ARM指令存储**

- 处理器处于`ARM状态`时
  所有指令在内存的起始地址必须是4的整数倍
  PC值由其[31:2]决定，[1:0]位未定义
- 处理器处于`Thumb状态`时
  所有指令在内存的起始地址必须是2的整数倍
  PC值由其[31:1]决定，[0]位未定义



#### ARM工作模式

ARM有8个基本的工作模式

| 工作模式 | 说明                                                        |
| -------- | ----------------------------------------------------------- |
| USER     | **非特权模式**，一般在**执行上层的应用程序**时ARM处于该模式 |
| FIQ      | 当一个**高优先级中断**产生后ARM将进入这种模式               |
| IRQ      | 当一个**低优先级中断**产生后ARM将进入这种模式               |
| SVC      | 当**复位或执行软中断**指令后ARM将进入这种模式               |
| Abort    | 当产生**存取异常**时ARM将进入这种模式                       |
| Undef    | 当**执行未定义的指令**时ARM将进入这种模式                   |
| System   | 使用和User模式相同寄存器集的**特权模式**                    |
| Monitor  | 为了安全而扩展出的用于执行**安全监控代码的模式**            |



### ARM寄存器组织

#### 0.**寄存器(Register)**

- 寄存器是CPU内部用于存储指令操作数,程序状态和中间结果的**高速存储单元**
- 是指令执行过程中访问速度最快的存储资源，是处理器执行体系结构(ISA)的一部分。
- 寄存器是 CPU 的“高速缓存的最顶层”。内存和外设都慢，CPU 每条指令执行时主要和寄存器直接交互。所以编译器、操作系统、驱动都极其依赖寄存器模型。

ARMv8-A（又名AArch64）架构定义了 31 个通用寄存器 + 若干特殊控制寄存器。

不同的处理器寄存器的组织也有所不同,但是是类似的,下面介绍AArch64架构

---



#### 1.**通用寄存器**

ARMv8-A 架构定义 **31 个 64-bit 的通用寄存器（X0–X30）**，用于存放函数参数、返回值、临时变量、栈帧信息等。它们构成 AArch64 指令集的基本操作对象。

通过不同的名字集可以操作寄存器的不同部分

```ini
X0-X30=操作寄存器全部的64位数据
W0-W30=操作寄存器中低32位的数据(例如，处理旧版 32 位应用程序数据，或者执行只需要 32 位整数的快速运算)
```

- X0~X7:参数 & 返回值寄存器( **Scratch Registers**)
  用于传递函数的前 8 个参数，并承担函数返回值寄存器（X0）

  调用函数时把参数放到X0-X7,调用结束后,返回值放在X0

  函数参数过多时,多余的参数会放入内存(栈)中

  

- X8:间接返回寄存器（Indirect Result Location Register）

  当函数返回“复杂结构体”时，返回值可能无法放进 X0，这时会用 X8 传递返回值的地址。

  

- X9–X15：临时寄存器（Scratch Registers）

  调用者保存寄存器（caller-saved）。函数调用时不保证被保留。

  用于存储局部变量,中间结果等在函数调用过程中可以被随意覆盖或破坏的数据

  

- X19–X28：被调用者保存寄存器（Callee-Saved）

  函数调用时，**被调用者**必须负责保护它们的内容。

  编译器会把这些寄存器用于长期变量（如循环计数、指针等)。

  

- X29：FP（Frame Pointer，帧指针）

  FP 用于表示当前栈帧的基地址。它帮助调试器和异常处理器定位局部变量和返回地址。

  用于在gdb调试中回溯堆栈

  

- X30：LR（Link Register，链接寄存器）

  LR 保存函数调用的返回地址。当执行 BL（Branch with Link）指令调用子程序时，CPU 会自动把下一条指令的地址写入 X30。

  可以将LR理解为一个书签:

  ```html
  当你正在阅读一本书（主程序流程），突然需要翻到附录去看一个参考资料（调用子函数），你会用一个书签标记你当前看到哪一页的哪一行，以便稍后能准确地回到原来的阅读位置继续阅读。
  LR的作用就是这个“书签”，它存储了“返回地址”（Return Address）。
  ```

  



#### 2.**特殊寄存器**

>  **驱动、异常机制、操作系统上下文切换** 的核心。

- SP（Stack Pointer，栈指针）

  SP 寄存器保存当前栈顶地址，用于支持函数调用、局部变量存储和异常上下文保存。

  ARM有两个SP(SP_EL0→用户态,SP_EL1→内核态)

  `SP_EL0` 和 `SP_EL1` 是两个**独立的物理寄存器**，在不同的 CPU 运行模式下被激活使用。它们确保了用户程序和操作系统内核拥有各自独立的、受保护的“工作台”（栈空间），从而提高了系统的稳定性和安全性。

  

- PC（Program Counter，程序计数器）

  PC 保存下一条即将执行的指令地址。ARM 在执行指令流的时候通过更新 PC 进行顺序执行或分支跳转。

  

- PSTATE（Processor State，处理器状态寄存器）

  PSTATE 是处理器状态寄存器，存储条件码标志、当前异常等级、执行状态（AArch64/AArch32）和中断屏蔽位等控制信息。

  PSTATE 记录着 CPU 当前“运行模式”和“状态标志”。

  

#### 3.**寄存器的工作流程示例**

下面通过一个简单的函数调用场景，来说明这些寄存器是如何协同工作的。

假设主程序 `main()` 调用子函数 `calculate_sum(a, b)`：

```c
// main 函数 (调用者 Caller)
int main() {
    int x = 5;
    int y = 10;
    int result;
    x=x+y;
    result = calculate_sum(x, y); // <-- 函数调用发生在这里
    // ... 使用 result
}

// calculate_sum 函数 (被调用者 Callee)
int calculate_sum(int a, int b) {
    int sum;
    sum = a + b;
    return sum;
}
```

流程如下:

| 步骤                              | 描述                                                         | 涉及的寄存器操作                                             |
| :-------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1. `main` 函数准备**            | `main` 函数运行在用户态 (EL0)，使用 `SP_EL0` 和一组通用寄存器来管理自己的局部变量 (`x`, `y`, `result`)。 | **SP_EL0** 指向 `main` 的栈帧顶部。使用  **Scratch Registers**(如 X0-X7)** 存储 `x` 和 `y`。 |
| **2.一步步执行指令**              | main函数完成相应的运算任务`x+y`                              | PC不断自增更新执行下一条指令                                 |
| **3. 参数传递与调用**             | `main` 准备调用 `calculate_sum`，需要传递参数。              | 将 `x` 的值放入 **X0** (第一个参数)，将 `y` 的值放入 **X1** (第二个参数)。 |
| **4. 执行 `BL` 指令**             | CPU 执行 `BL calculate_sum` 指令，跳转到子函数。             | **核心操作：** CPU 自动将 `main` 函数的下一条指令地址存入 **X30 (LR)**。 |
| **5. 进入子函数 `calculate_sum`** | 开始执行子函数代码，使用子函数的栈空间。                     | **SP_EL0** 指针下移，分配子函数的局部变量 (`sum`) 空间。子函数可以使用 Scratch Registers **(X0-X7)**。 |
| **6 执行子函数逻辑**              | 执行 `sum = a + b` 的计算。                                  | 使用 **X0** 和 **X1** 中接收的参数值进行加法运算，结果存储在另一个 Scratch Register 中。 |
| **7. 返回结果**                   | 子函数计算完毕，准备返回结果。                               | **调用约定：** 将最终结果放入 **X0** 寄存器中，作为返回值传递回调用者。 |
| **8. 执行 `RET` 指令**            | 子函数执行 `RET`（返回）指令。                               | **核心操作：** CPU 从 **X30 (LR)** 中读取之前保存的返回地址，并跳转回 `main` 函数的那条指令。 |
| **9. `main` 函数继续执行**        | `main` 函数恢复执行，处理返回值。                            | 从 **X0** 中取出返回的 `sum` 值，赋值给 `result` 变量。释放子函数的栈空间，**SP_EL0** 指针上移恢复原位。 |
| 10.**隔离与安全**                 | 发生系统调用或中断时                                         | CPU 从 EL0 切换到 EL1，自动使用独立的 `SP_EL1` 栈，保护了内核数据的安全。 |





### ARM异常机制

> 这一节是之后理解 **系统调用、中断、Linux 内核态切换与驱动行为** 的核心基础。
> 如果说寄存器描述了“CPU 现在的状态”，那么 **异常机制描述 CPU 如何切换状态**。

#### 1.异常

**概述**

异常是指程序执行过程中发生的、需要 CPU 暂停当前执行流并切换到特权代码处理的事件。

在 ARM 中，异常包括：同步异常（如系统调用）、中断（IRQ/FIQ）、SError、调试事件等。

**异常等级**

AArch64将执行环境划分为4个特权等级,等级逐渐升高

每一级拥有不同权限，异常可能从低等级陷入高等级，由高等级代码处理后返回。

| 等级    | 名称       | 典型运行环境                 |
| ------- | ---------- | ---------------------------- |
| **EL0** | 用户态     | 普通用户程序（应用层）       |
| **EL1** | 内核态     | 操作系统内核（Linux Kernel） |
| **EL2** | 虚拟化层   | Hypervisor（KVM、虚拟化）    |
| **EL3** | 安全监控层 | TrustZone Secure Monitor     |



**异常向量表**

异常向量表是一段固定布局的代码入口地址集合，每种类型的异常都有对应的入口地址。当异常发生时，CPU 自动跳转到对应地址执行处理程序。(类似中断向量表)

AArch64 对每个 EL 都有独立的一套向量表。



**Trap(异常陷入)**

Trap 指用户态或低特权级代码触发异常，使 CPU 切换到更高特权级执行预定义的异常处理流程。Trap 发生时，CPU 会保存必要现场（PC、PSTATE、SP），更新异常等级，并跳向向量表入口。

典型 trap：

- 系统调用（SVC 指令）
- 内存访问非法
- 页缺失
- 断点异常
- 中断（IRQ、FIQ）

#### 2.ARMv8-A异常

ARMv8-A 架构将异常分为四大类：**同步异常 (Synchronous Exception)**、**中断 (IRQ)**、**快速中断 (FIQ)** 和 **系统错误 (SError)**。



1. **同步异常(Synchronous Exceptions)**

   同步异常是指**与当前正在执行的指令直接相关**的异常。它们在指令执行过程中或执行后立即发生，是可预测和精确的。

   **特点:**

   - **同步性：** 异常发生的位置与导致异常的指令有明确的架构定义关系，可以精准定位到是哪条指令出了问题。

   - **不可屏蔽：** 由于与当前执行流直接相关，无法简单地屏蔽它们。

   

   **发生场景**

   - 系统调用 (SVC, System Call)： 应用程序主动请求操作系统服务（例如，读写文件）时触发的软中断。
   - 内存管理单元 (MMU) 故障： 访问无效内存地址、试图写入只读内存区域（段错误）等。
   - 未定义指令： CPU 试图执行一条无法识别的指令。
   - 断点调试： 调试器设置的断点。

   

2. **中断 (IRQ, Interrupt ReQuest)**
   **特点:**

   - 可屏蔽： 操作系统可以通过设置 PSTATE 寄存器中的 I 位来暂时忽略（屏蔽）IRQ 中断。
   - 异步性： 可以在任何指令执行边界发生。

   **发生场景:**

   - 定时器中断： 定时器到期，通知操作系统执行调度任务。
   - 网络数据包到达： 网卡通知 CPU 有新数据需要处理。
   - 键盘输入： 用户按下按键。

   

3. **快速中断 (FIQ, Fast Interrupt reQuest)** 

   FIQ 是 ARM 架构中优先级**更高**的异步中断类型。在早期的 ARM 架构中，FIQ 享有更快的响应机制。在 ARMv8-A AArch64 模式下，IRQ 和 FIQ 的优先级和处理机制更为相似，它们主要用于将不同类型的中断路由到不同的异常级别（例如，IRQ 到 EL1，FIQ 可能到 EL3 的安全监控器）。

   **特点**:

   - **高优先级：** 比普通 IRQ 优先级更高。
   - **可屏蔽：** 可以通过设置 `PSTATE` 寄存器中的 F 位来屏蔽。
   - **发生场景：** 通常用于需要极低延迟的关键事件，比如某些高性能外设或安全相关的事件。 

   

4. **系统错误** **(SError, System Error / External Abort)**

   SError 是一种严重的系统故障信号，通常由硬件错误引起，例如内存奇偶校验错误、外部总线错误等。它通常代表了一个需要系统级别诊断甚至恢复的致命问题。 

   **特点:**

   - **严重性：** 表示潜在的硬件故障或外部异常中止。
   - **处理级别：** 通常路由到更高的异常级别（例如 EL3）进行处理。
   - **发生场景：** 硬件故障、不可恢复的内存错误。 



​     

---

#### **3.异常的发生**

当任何一种异常发生时,CPU会自动执行下面步骤

1. **保存状态：** 将当前的处理器状态（`PSTATE`）保存到 `SPSR_ELx` 寄存器中。
2. **保存返回地址：** 将发生异常时的返回地址（取决于异常类型，通常是当前指令或下一条指令的地址）保存到 `ELR_ELx` 寄存器中。
3. **切换特权级：** CPU 切换到目标异常级别（例如，从 EL0 切换到 EL1），并使用新的栈指针 (`SP_EL1`)。
4. **跳转处理：** CPU 读取对应异常级别的 `VBAR_ELx` 寄存器获取向量表基地址，然后根据异常类型计算偏移量，跳转到相应的异常处理程序入口开始执行。 

异常处理程序是一段内核代码，负责诊断问题、处理事件，并在完成后执行 `ERET`（Exception Return）指令返回到之前的执行流。 



> 下面按实际执行流程解释一次真实的“从 EL0 进入 EL1”。

1. 事件触发(例子:系统调用)

   用户态程序调用 `write()`，glibc 发出：

   ```nginx
   SVC #0
   ```

   SVC 是 ARM 的“系统调用指令”，必然导致异常。

2.  CPU 确定异常类型与等级

   CPU检查触发源:

   - SVC → 同步异常
   - 当前等级 → EL0
   - 目标等级 → EL1

   因此进入**“同步异常：从 EL0 进入 EL1”** 的向量表入口。

   ARM 对不同来源 + 方向都有不同入口，例如：

   ```nginx
   EL0 → EL1 同步异常
   EL0 → EL1 IRQ
   EL1 → EL1 SError
   ...
   #每种都有独立入口。
   ```

3. CPU自动保存现场

   CPU自动保存:

   - PC（发生异常时的执行地址） → ELR_EL1
   - PSTATE（条件码，中断屏蔽位等） → SPSR_EL1
   - 切换 SP 指向 EL1 的 SP_EL1
   - 切换执行模式到 EL1

4. CPU跳转到异常向量表入口

   比如 Linux 内核把异常向量表放在：

   ```c
   EL1 vector base: 0xffff0000xxxx0000
   ```

   SVC 的入口就在其中一个偏移位置。

   CPU 直接跳到那里执行。

5. 内核执行异常处理程序

   - 解析 SVC 号（系统调用号）

   - 调用内核中的实际实现，如 `sys_write()`

6. ERET指令返回用户态

   处理结束后执行

   ```nginx
   ERET
   ```

   CPU 会：

   - 恢复 PC = ELR_EL1
   - 恢复 PSTATE = SPSR_EL1
   - 切换回 EL0
   - SP 切回 SP_EL0

   用户程序继续执行，就像什么都没发生过



---

#### 4.异常分类

| 异常类型     | 特点             | 举例                |
| ------------ | ---------------- | ------------------- |
| **同步异常** | 指令执行直接导致 | SVC、除零、非法访存 |
| **IRQ**      | 可屏蔽中断       | 外设中断，如 UART   |
| **FIQ**      | 高优先级中断     | 安全相关设备        |
| **SError**   | 系统错误         | 硬件错误            |

驱动主要关心 **IRQ → 中断处理机制**。

---



### MMU与设备地址映射

> 简单了解

#### **MMU**

MMU 是 **内存管理单元 (Memory Management Unit)** 的缩写。它是现代计算机（包括 ARM 架构）中一个至关重要且复杂的硬件单元。

MMU 的主要功能是**将程序使用的虚拟内存地址转换成计算机硬件实际使用的物理内存地址**。

**功能**

1. **地址转换（虚拟地址 -> 物理地址）**

   每个运行的程序都认为自己拥有完整的、从 0 地址开始的一整块内存空间，这片空间称为**虚拟内存**。然而，实际上这些程序的数据可能分散在物理内存的不同位置。

   **MMU 的工作就是实时完成这种映射和转换：**

   - **程序看到的地址：** 虚拟地址 (Virtual Address, VA)
   - **硬件实际的地址：** 物理地址 (Physical Address, PA)

   当 CPU 执行指令，需要访问内存地址 A 时，它实际上是发出一个虚拟地址 A。MMU 拦截这个请求，查阅一个称为**“页表”（Page Table）**的映射表，找到 A 对应的物理地址 B，然后才真正访问物理地址 B 处的数据。

2.  **内存保护与权限控制**

   MMU 也是一个严格的“门卫”。在进行地址转换的同时，它还会检查程序是否有权访问该内存区域。

   - **隔离应用程序：** MMU 确保一个程序不能恶意或意外地访问另一个程序的内存空间，这防止了一个程序的崩溃导致整个系统崩溃。
   - **权限管理：** 它可以实施只读、只写或禁止执行等权限（例如，代码段通常是只读且可执行，数据段是可读写的）。
   - **用户态与内核态隔离：** MMU 确保用户态的程序无法直接访问内核态的内存区域。

3.  **内存管理与优化**

   MMU 支持了一些高级内存管理技术：

   - **分页 (Paging)：** 虚拟内存和物理内存都被分割成固定大小的块（通常是 4KB），称为“页”（Pages），方便管理和映射。
   - **按需调页 (Demand Paging)：** 只有当程序实际需要访问某块内存时，才将其从硬盘加载到物理内存中。
   - **内存共享：** 允许多个程序共享同一块物理内存（例如，共享同一个操作系统的代码库），节省内存资源。

---

#### **设备地址映射**

设备地址映射（Device Address Mapping），在计算机系统中，是指**将外围硬件设备（Peripheral Devices）的内部寄存器和内存，映射到 CPU 能够访问的地址空间中的过程**。

这个过程使得 CPU 可以像访问普通内存一样，通过读写特定的内存地址来控制硬件设备。这种技术通常称为 **内存映射 I/O (Memory-Mapped I/O, MMIO)**。



---

---



## ARM汇编基础

> 学习汇编不是为了经常写汇编程序,而是在于理解CPU如何执行C代码和MMIO操作

#### **汇编概述**

**指令**

指令是 CPU 能够直接执行的最小操作单位，由操作码（opcode）与操作数组成，用于控制处理器完成算术、逻辑、内存访问、控制流等行为。

C 代码会被编译成 ARM 指令。理解这些指令，就能理解驱动对寄存器做了什么。

**指令集**

处理器能识别的指令的集合称为指令集

不同架构的处理器指令集不同

指令集是处理器对开发者提供的接口

**汇编**

**汇编语言**是**人类可读的指令集的文本表示**,是指令集的直接接口

程序员使用汇编语言编写程序，然后使用**汇编器（Assembler）**这个工具将其翻译成 CPU 能够执行的机器码。

每条汇编都会唯一对应一条机器码，且CPU能直接识别和执行
即汇编中所有的指令都是CPU能够识别和执行的

汇编中寄存器的使用、栈的分配与使用、程序的调用、参数的传递等都需要自己维护



**ARM汇编组成**

1. 指令： 能够编译生成一条32位的机器码，且能被CPU识别和执行
2. 伪指令：本身不是指令，编译器可以将其替换成若干条等效指令
3. 伪操作：不会生成代码，只是在编译之前告诉编译器怎么编译



---



#### 环境搭建

使用vscode搭建arm汇编开发环境(其它类似交叉编译工具同理)

**系统环境**

必要的开发工具链

```bash
sudo apt update
sudo apt install build-essential gdb
# build-essential 包含了 gcc, make 等基础工具，也包含了 binutils
```

VS Code扩展

1.**Assembly Language** 提供了良好的汇编语言语法高亮显示。

2.C/C++调试汇编代码通常依赖于 C/C++ 扩展提供的 GDB 调试接口。



创建项目

1. 使用VScode打开一个工作目录

2. `Ctrl+Shift+P`输入 **"Tasks: Configure Task"**。

3. 选择 **"Create tasks.json file from template"**。

4. 选择 **"Others"** 模板。创建一个 `.vscode/tasks.json` 文件。将其内容修改为合适架构的编译命令。如下(AArch64)
   ```json
   {
       "version": "2.0.0",
       "tasks": [
           {
               "label": "build assembly (AArch64)",
               "type": "shell",
               "command": "aarch64-linux-gnu-as ${file} -o ${fileBasenameNoExtension}.o && aarch64-linux-gnu-ld ${fileBasenameNoExtension}.o -o ${fileBasenameNoExtension}",
               "group": {
                   "kind": "build",
                   "isDefault": true
               },
               "presentation": {
                   "reveal": "always"
               },
               "problemMatcher": "$gcc"
           }
       ]
   }
   
   ```

   5.创建hello.s汇编文件,编写hello world程序

   ```assembly
   .global _start          // 声明 _start 符号为全局可见
   
   .section .data          // 定义数据段
   msg:
       .ascii "Hello World Buer!\n" // 要打印的字符串
   len = . - msg           // 计算字符串的长度
   
   .section .text          // 定义代码段
   _start:                 // 程序入口点
   
       // --- 系统调用 write (sys_write) ---
       mov x0, #1          // 第一个参数：文件描述符 1 (stdout 标准输出) 放入 X0
       ldr x1, =msg        // 第二个参数：缓冲区地址 (msg) 放入 X1
       mov x2, len         // 第三个参数：长度 (len) 放入 X2
       mov x8, #64         // syscall 号码 64 (AArch64 中的 write) 放入 X8
       svc #0              // SVC (Supervisor Call) 触发系统调用
   
       // --- 系统调用 exit (sys_exit) ---
       mov x0, #0          // 第一个参数：退出状态码 0 放入 X0
       mov x8, #93         // syscall 号码 93 (AArch64 中的 exit) 放入 X8
       svc #0              // 触发系统调用
   ```

   `Ctrl+Shift+B`生成可执行文件

   执行程序:

   ```bash
   ./hello
   ```
   
   调试程序
   
   编译时加入`-g`参数,然后使用gdb命令调试

#### AArch64指令体系

ARM指令大体分为几类:

1. **数据处理指令（算术、逻辑、移位）**

2. **加载/存储指令（访问内存和 MMIO 寄存器）**

3. **分支与跳转指令（流程控制）**   

此外还有(了解):

4. 状态寄存器传送指令(访问/读写CPSR寄存器)
5. 软中断指令(触发软中断异常)
6. 协处理器指令(操控协处理器的指令)

汇编命令不区分大小写,如`MOV`=`mov`

##### 1.数据处理指令

> 这些指令操作寄存器,不访问内存

- MOV:将立即数或另一个寄存器的值复制到目标寄存器。

  ```less
  MOV X0, #1        // X0 = 1
  MOV X1, X0        // X1 = X0
  ```

  

- ADD/SUB:加减法运算

  ```less
  ADD X0, X1, X2     // X0 = X1 + X2
  SUB X0, X1, X2     // X0 = X1 - X2
  ADD X0, X1, #10    //X0=X1+10
  ADD x0,x1,0xa1 	   //X0=X1+0XA1
  ```

  

- AND / ORR / EOR:位逻辑运算

  ```less
  AND X0, X1, #0xFF     // X0 = X1 & 0xFF  与
  ORR X0, X1, #1<<3     // X0 = X1 | (1 << 3) 或
  EOR X0, X1, #1<<2	  // X0 = X1 ^ (1 << 3) 异或
  ```

  

- LEL/LSR:左移/右移

  ```less
  LSL X0, X1, #4        // 左移 4 位
  LSR X0, X1, #2        // 右移 2 位
  ```



##### 2.加载存储指令

> 加载指令将内存（或外设寄存器）的值读入寄存器；
>
> 存储指令将寄存器的值写入内存（或寄存器地址）。
>
> ARM 强制采用“寄存器-内存分离”，也就是 **不能直接对内存做算术运算**。
>
> ```less
> 不能 ADD [addr], X1
> ```

-  LDR — 从内存加载到寄存器

  ```less
  //基本格式
  LDR Xd, [Xn]         // Xd = *(uint64_t *)Xn
  //如
  LDR X0, [X1]
  //带偏移
  LDR X0, [X1, #8]     // X0 = *(X1 + 8)
  //一般先使用MOV把要操作的地址存入寄存器,再使用LDR加载
  MOV X1, #0xFE200000	 //假设外设地址
  LDR W0, [X1]         // 读 GPIO 寄存器
  ```

- STR — 写寄存器到内存

  ```less
  //同理
  STR Xd, [Xn]         // *(uint64_t*)Xn = Xd
  MOV X1, #0xFE200000   // GPIO 基址
  MOV X0, #1
  STR W0, [X1]          // 写寄存器 (低32-bit,见前面提到的名字集内容)
  ```

##### **3.标签(Label)**

> **标签（Label）** 是汇编语言中的一个**符号名称**，用于标记内存中的一个特定位置（通常是指令的地址或数据的位置）。



- **人类可读性：** 程序员使用标签来指代一个地址，而不必手动计算和输入具体的十六进制内存地址（例如 `0x400088`）。
- **汇编器处理：** 当汇编器将汇编代码转换成机器码时，它会计算出标签所代表的实际内存地址，并将 `B` 指令的目标地址替换为这个实际地址值。

**标签的特点**:

- **以冒号结尾：** 在许多汇编器（包括 GNU Assembler `as`）中，标签通常以冒号 `:` 结尾，例如 `_start:` 或 `my_data:`。
- **作用域：** 默认情况下，它们在当前文件中可见。使用 `.global` 伪指令可以使标签在整个程序（跨文件）中可见

```less
.global _start //声明start全局可见
//msg是一个标签
msg:
    .ascii "Hello World Buer!!\n" // 要打印的字符串
```



##### 4.分支跳转指令(流程控制)

- B — 无条件跳转

  用于循环或简单流程控制

  ```less
  B label  //跳转到对应标签处
  ```

- BL — 带返回地址跳转（类似函数调用）

  会在跳转前将下一条指令的地址保存到X30(LR寄存器)用于调用子程序

  ```less
  BL func          // X30 = return address
  ```

- CBZ/CBNZ — 判断寄存器是否为零并跳转

  ```less
  CBZ X0, label     // 若 X0 == 0 跳转
  CBNZ X0, label    // 若 X0 != 0 跳转
  ```

- 条件跳转（基于 PSTATE.NZCV）

  在 ARM 架构中，CPU 内部有一个特殊的**状态寄存器（`PSTATE` 或 `CPSR`）**。在执行算术或逻辑运算指令（例如 `CMP` 比较指令、`SUBS` 带状态更新的减法指令、`ADDS` 带状态更新的加法指令等）之后，这个寄存器中的几个关键标志位会被设置或清零：

  - **Z (Zero Flag)：** 零标志。如果运算结果为 0，Z=1；否则 Z=0。
  - **N (Negative Flag)：** 负数标志。如果结果为负数，N=1；否则 N=0。
  - **C (Carry Flag)：** 进位标志。表示无符号运算时是否有进位或借位。
  - **V (Overflow Flag)：** 溢出标志。表示有符号运算时是否发生溢出。

  这些依赖之前执行的比较或运算指令设置标志位。例如:

  ```less
  CMP X1, X2
  B.EQ equal//如果等于,跳转到equal标签
  ```

  详细指令

  | 指令   | 含义                            | 满足的条件            | 使用场景                     |
  | :----- | :------------------------------ | :-------------------- | :--------------------------- |
  | `B.EQ` | Branch if EQual                 | Z == 1 (零标志被设置) | 结果等于零，或两个值相等     |
  | `B.NE` | Branch if Not Equal             | Z == 0 (零标志未设置) | 结果不等于零，或两个值不相等 |
  | `B.GT` | Branch if Greater Than          | N==V 且 Z==0          | 有符号数比较：大于           |
  | `B.LT` | Branch if Less Than             | N!=V                  | 有符号数比较：小于           |
  | `B.GE` | Branch if Greater than or Equal | N == V                | 有符号数比较：大于等于       |
  | `B.LE` | Branch if Less than or Equal    | Z==1 或 N!=V          | 有符号数比较：小于等于       |
  | `B.HI` | Branch if HIgher                | C==1 且 Z==0          | 无符号数比较：大于           |
  | `B.LS` | Branch if Lower or Same         | C==0 或 Z==1          | 无符号数比较：小于等于       |

**示例**:

简单循环

```less
    MOV X0, #10         // 初始化计数器 X0 为 10

loop_start:
    SUBS X0, X0, #1     // X0 减 1，并更新条件标志 (SUBS 带 S 后缀会更新标志)

    CMP X0, #0          // 比较 X0 和 0
    B.NE loop_start     // 检查 Z==0？只要 X0 不等于 0，就跳转回 loop_start 

loop_end:
    // 当 X0 达到 0 时，Z 标志被设置，B.NE 不再跳转，程序继续执行这里

```

简单if/else结构

```less
    MOV X0, #10         // X0 = 10
    MOV X1, #5          // X1 = 5

    CMP X0, X1          // 比较 X0 和 X1 (执行 10 - 5)。结果非零，Z=0。
    B.EQ label_equal    // 检查 Z==1？不满足，不跳转，继续执行下一行
	
	B.LT label_less     //同理
//前面条件都不满足,代码会顺序执行label_greater的内容,相当于else
label_greater:
    // ... 如果 X0 > X1，执行这里的代码 ...
    MOV X2, #1          // 设置 X2 为 1
    B end_if            // 跳转到 if 结束处

label_less:
	MOV X2, #2          // 设置 X2 为 1
	B end_if			//跳转到 if 结束处
label_equal:
    // ... 如果 X0 == X1，执行这里的代码 (这里不会执行到) ...
    MOV X2, #0

end_if:
    // 程序继续执行这里...

```

